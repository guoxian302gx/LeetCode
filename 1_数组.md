* 双指针
* 二分查找
* 滑动窗口的双指针



283. 移动零
https://leetcode.cn/problems/move-zeroes/description/

left : 新的数组，不包含0， left代表[0,left) , left代表下一个元素  
right : 遍历数组， 寻找一个不为0的元素

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {

        int left = 0;
        int right = 0;
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] != 0) {
                swap(nums[left++], nums[i]);
            }
        }
        
        // int left = 0, right = 0; 
        // //[*，left），left为处理好的序列的下一个位置，即前面都不为0; 
        // // left当前位置可能为0
        // //right为当前idx遍历位置

        // while(right<nums.size()){
        //     if(nums[right] != 0) { // 当前数!=0 , 交换， left 和right 都右移动
        //         swap(nums[left], nums[right]);
        //         left++;
        //         right++;
        //     } else {
        //         right++;
        //     }
        // }

        
    }
};
```


977. 有序数组的平方
https://leetcode.cn/problems/squares-of-a-sorted-array/description/
双指针，从两头找最大的，从后往前插入
```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        vector<int> res(nums.size(),0);
        int idx = right;
        while(left <= right) {
            if(nums[left]*nums[left] >= nums[right]*nums[right]) {
                res[idx--] = nums[left] * nums[left];
                left++;
            } else {
                res[idx--] = nums[right] * nums[right];
                right--;
            }
        }
        return res;
    }
};
```

209. 长度最小的子数组
子数组和>=target 的最小长度

https://leetcode.cn/problems/minimum-size-subarray-sum/description/
```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, right = 0;
        int n = nums.size();
        int cur_sum = 0;
        int res = n+1;
        while(right < n) {
            cur_sum += nums[right];
            right++;
            while(cur_sum >= target) {
                res = min(res, right - left);
                cur_sum -= nums[left];
                left++;
            }
        }
        return res == n+1 ? 0 : res;
    }
};
```

59. 螺旋矩阵 II
https://leetcode.cn/problems/spiral-matrix-ii/description/
/*
给定一个n； 然后有n*n个元素按旋转的方式，生成对应矩阵
n = 2 ;
生成矩阵：
1 2 
4 3

元素一定是n*n个；直接模拟生成即可；
top bottom left right撞墙后就转弯；

while 可以用 whiletrue 然后用++top > bottom 来 进行break
*/
```
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int left = 0;
        int right = n-1;
        int top = 0;
        int bottom = n-1;
        int k = 1;
        vector<vector<int>> res(n, vector<int>(n,0));
        while(k <= n*n) {
            for(int i = left; i <= right; i++, k++)
                res[top][i] = k;
            top++;
            for(int i = top; i<= bottom; i++, k++)
                res[i][right] = k;
            right--;
            for(int i = right; i>= left; i--, k++)
                res[bottom][i] = k;
            bottom--;
            for(int i = bottom; i >= top; i--, k++)
                res[i][left] = k;
            left++;
        }
        return res;
    }
};
```