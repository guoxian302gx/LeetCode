# 定长滑动窗口 基础题

* 1456. 定长子串中元音的最大数目
https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/
```cpp 

class Solution {
public:
    int maxVowels(string s, int k) {
        int res = 0;
        int cur = 0;
        for(int i = 0; i < s.size(); i++) {
            // 1、 入窗
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' )
                cur++;
            if(i-k+1 < 0 ) continue; // 窗口大小未满足 i-k+1 < 0 

            // 2、更新
            res = max (res, cur);

            // 3、出窗
            char out = s[i-k+1]; // 最左侧元素
            if(out == 'a' || out == 'e' || out == 'i' || out == 'o' || out == 'u')
                cur--;
        }
        return res;
    }
};

```

* 643. 子数组最大平均数 I
https://leetcode.cn/problems/maximum-average-subarray-i/description/
```cpp 
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        if(k>nums.size()) return 0.0;
        int sum = 0;
        int res = INT_MIN;
        for(int i = 0; i < nums.size(); i++) {
            //in
            sum += nums[i];
            if(i-k+1<0) continue;

            //update
            res = max(res, sum);

            //out
            sum -= nums[i-k+1];
        }
        return double(res)/k;
    }
};

```


* 1343. 大小为 K 且平均值大于等于阈值的子数组数目
https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/
```cpp 

class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int res = 0;
        int sum = 0;
        for(int i = 0; i < arr.size(); i++) {
            //in
            sum += arr[i];
            if(i-k+1<0) continue;

            // update
            if(sum >= threshold*k) res++;

            //out
            sum -= arr[i-k+1];
        }
        return res;
    }
};

```


* 2090. 半径为 k 的子数组平均值
https://leetcode.cn/problems/k-radius-subarray-averages/description/
```cpp 
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        vector<int> res(nums.size(), -1);
        long sum = 0;
        int length = k*2+1;
        if(k>nums.size()) return res;

        for(int i = 0; i < nums.size(); i++) {
            //in 
            sum += nums[i];
            if(i-length+1 < 0) continue;

            // update
            res[i-k] = sum/length;

            //out
            sum -= nums[i-length+1];
        }
        return res;
    }
};
```


* 2379. 得到 K 个黑块的最少涂色次数
https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/
```cpp 

class Solution {
public:
    int minimumRecolors(string blocks, int k) {
        // 定长的窗口，最少有几个W；
        int n = blocks.size();
        int cur_num = 0; // W的个数
        int res = n;
        for(int i = 0; i < n; i++) {
            // in
            if(blocks[i] == 'W')
                cur_num++;
            if(i-k+1 < 0) continue;

            // update
            res = min(res, cur_num);

            //out
            if(blocks[i-k+1] == 'W')
                cur_num--;
        }
        return res;
    }
};
```

* 2841. 几乎唯一子数组的最大和
https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/

``` cpp 
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        int valid = 0; // 窗口内唯一数组个数；
        unordered_map<int, int> windows;
        long long res = 0;
        long long sum = 0;
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            //in
            sum += nums[i];
            windows[nums[i]]++;
            if(windows[nums[i]] == 1) valid++;

            if(i-k+1 < 0) continue;

            //update
            if(valid >= m) res = max(res, sum);

            //out 
            sum -= nums[i-k+1];
            if(windows[nums[i-k+1]] == 1) valid--;
            windows[nums[i-k+1]]--;
        }
        return res;
    }
};
```


* 2461. 长度为 K 子数组中的最大和
https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/
``` cpp 
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        long long res = 0;
        long long sum = 0;
        int n = nums.size();
        unordered_map<int, int> windows;
        int valid = 0;

        for(int i = 0; i < n; i++) {
            //in 
            sum += nums[i];
            windows[nums[i]]++;
            if(windows[nums[i]] == 1)
                valid++;

            if(i-k+1<0) continue;

            // update
            if(valid == k) res = max(res, sum);

            //out 
            if(windows[nums[i-k+1]] == 1)
                valid--;
            windows[nums[i-k+1]]--;
            sum -= nums[i-k+1];
        }
        return res;
    }
};
```


* 1423. 可获得的最大点数
https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/
``` cpp 
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        // k 张最大值， 就是 n-k的最小值， 因为只能从两头拿；所以最小值一定是中间的子数组；
        int n = cardPoints.size();
        k = n-k;
        
        int res = INT_MAX;
        int sum = 0;
        int total_sum = 0;
        for(int i = 0; i < n; i++) {
            total_sum += cardPoints[i];
            //in 
            sum += cardPoints[i];
            if(i-k+1<0) continue;

            //update
            res = min(res, sum);

            sum -= cardPoints[i-k+1];
        }
        if(k == 0) return total_sum;
        return total_sum - res;
    }
};
```


* 1052. 爱生气的书店老板
https://leetcode.cn/problems/grumpy-bookstore-owner/
``` cpp 
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        // 这里是第i分钟结束，这个顾客就会立刻离开，顾客只呆一分钟；
        //不生气时候的值s1 
        //s2为minutes 窗口 生气的最大顾客数量；
        // return s1 + s2；
        int s1 = 0;
        int s2 = 0;
        int n = customers.size();
        int sum = 0;
        for(int i = 0; i < n; i++) {
            // s1 
            if(grumpy[i] == 0) s1 += customers[i];
            
            // s2 
            //in
            if(grumpy[i] == 1) sum += customers[i];
            if(i-minutes+1 < 0) continue;
            //update
            s2 = max(s2, sum);
            //out 
            if(grumpy[i-minutes+1] == 1) sum -= customers[i-minutes+1];
        }
        return s1+s2;
    }
};
```


* 1652. 拆炸弹
https://leetcode.cn/problems/defuse-the-bomb/description/
``` cpp 


```


* 3439. 重新安排会议得到最多空余时间 I
https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/description/
``` cpp 
// - n场会议，有n+1个空闲区间，左右两边都要算上
// - k个重新安排，相当于合并相邻的k+1个空闲区间。
// - 即求k+1 个连续数组的最大和； 
// - 每一个数组的取值就是空闲时间, start[0], ...[start[i] - end[i-1]].... endtime-end[n-1] 

class Solution {
public:
    int maxFreeTime(int eventTime, int k, vector<int>& startTime, vector<int>& endTime) {
        int n = startTime.size(); //  n + 1个空闲时间段
        int len = k + 1; // len 个 最大和;
        int sum = 0;
        int res = 0;
        for(int i = 0; i <= n; i++) {
            // in 
            if(i == 0) {
                sum += startTime[0];
            } else if (i == n) {
                sum += eventTime - endTime[n-1];
            } else {
                sum += startTime[i] - endTime[i-1];
            }
            if(i-len+1<0) continue;

            //update 
            res = max(res, sum);

            //out
            if(i-len+1 ==0) {
                sum -= startTime[0];
            } else if (i-len+1 == n) {
                sum -= eventTime - endTime[n-1];
            } else {
                sum -= startTime[i-len+1] - endTime[i-len];
            }
        }
        return res;
    }
};
```


* 2134. 最少交换次数来组合所有的 1 II
https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/description/
``` cpp 
class Solution {
public:
    int minSwaps(vector<int>& nums) {
        int k = 0;
        for(auto num : nums)
            k += num;
        if(k == 0) return 0;
        // 定长为k， k中1最多
        int sum = 0;
        int res = 0;
        int n = nums.size();
        // n-k+1 相当于i=0时候的左边界 i-k+1
        for(int i = n-k+1; i < n; i++)
            sum+=nums[i];
        for(int i = 0; i < n; i++) {
            //in 
            sum += nums[i];
            // update
            res = max(res, sum);
            //out
            int left = i - k + 1 >= 0 ? i-k+1 : i-k+1 + n;
            sum -= nums[left];
        }
        return k-res;

    }
};
```


# 定长窗口进阶题
* 438. 找到字符串中所有字母异位词
https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked

```cpp
// 1、定长窗口，左边left 就是 i-k+1
// 2、 in - update - out 的模版
// 3、 注意一定要判断当前字母是否在map中，否则会影响map.size()和valid的判断；
// 4、 in 和 out 就是正逆操作；
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int k = p.size();
        int n = s.size();
        unordered_map<char, int> windows, map;
        for(auto c : p)
            map[c]++;
        int valid = 0;
        vector<int> res;

        for(int i = 0; i < n; i++) {
            //in
            if(map.find(s[i]) != map.end()) {
                windows[s[i]]++;
                if(windows[s[i]] == map[s[i]])
                    valid++;
            }
            if(i-k+1 < 0) continue;

            //update
            if(valid == map.size()) res.push_back(i-k+1);

            //out
            if(map.find(s[i-k+1]) != map.end()) {
                if(windows[s[i-k+1]] == map[s[i-k+1]])
                    valid--;
                windows[s[i-k+1]]--;
            }
        }
        return res;
    }
};
```


# 不定长划窗1 ： 越短越合法/求最长/最大


* 3. 无重复字符的最长子串
https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/
``` cpp 
// - 定长是用i-k+1来定位left
// - 不定长先定义left = 0

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> windows;
        int left = 0;
        int n = s.size();
        int res = 0;
        for(int right = 0; right < n; right++) {
            //in 
            char c = s[right];
            windows[c]++;

            //out
            while(windows[c] > 1) {
                windows[s[left]]--;
                left++;
            }
            res = max(res, right - left + 1);
        }
        return res;
    }
};
```


* 3090. 每个字符最多出现两次的最长子字符串
https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/description/

``` cpp 
class Solution {
public:
    int maximumLengthSubstring(string s) {
        int n = s.size();
        unordered_map<char, int> windows;
        int left = 0;
        int res = 0;
        for(int right = 0; right < n; right++) {
            //in 
            windows[s[right]]++;
            
            //out
            while(windows[s[right]]>2) {
                windows[s[left]]--;
                left++;
            }
            res = max(res, right - left + 1);
        }
        return res;
    }
};
```


* 1493. 删掉一个元素以后全为 1 的最长子数组
https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/
``` cpp 
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        //寻找只有一个0的最大子数组和
        int n = nums.size();
        int left = 0;
        int res = 0;
        int sum = 0;
        int valid = 0;
        int total_sum = 0;
        for(int right = 0; right < nums.size(); right++) {
            total_sum += nums[right];
            //in 
            sum += nums[right];
            if(nums[right] == 0) valid++;
            //out
            while(valid > 1) {
                if(nums[left] == 0) 
                    valid--;
                sum -= nums[left];
                left++;
            };
            res = max(res, sum);
        }
        if(total_sum == n) return n-1;
        return res;
    }
};
```


* 3634. 使数组平衡的最少移除数目
https://leetcode.cn/problems/minimum-removals-to-balance-array/description/
求最长/最大/最小/最短/这类字眼，都是用划窗较多；

``` cpp 
class Solution {
public:
    int minRemoval(vector<int>& nums, int k) {
        // 排序后，求一个划窗，left 和 right 有 left*k <= right的最大长度;
        sort(nums.begin(), nums.end());
        int left = 0;
        int res = 0;
        int n = nums.size();
        for(int right = 0; right < n; right++) {
            //in 
            while(1LL * nums[left] * k < nums[right]) {
                left++;
            }
            res = max(res, right - left + 1);
        }
        return n-res;
    }
};
```

* 1208. 尽可能使字符串相等
https://leetcode.cn/problems/get-equal-substrings-within-budget/description/

``` cpp 
// 这里是最长的符合条件的子串；
// 每个idx有一个代价；求代价和<=maxCost的最长子串
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
        //求最长字符，这里是用划窗;
        int left = 0;
        int res = 0;
        int n = s.size();
        int sum = 0;
        for(int right = 0; right < n; right++) {
            sum += abs(s[right] - t[right]);
            while(sum > maxCost) {
                sum -= abs(s[left] - t[left]);
                left++;
            }
            res = max(right-left+1, res);
        }
        return res;
    }
};
```

* 904. 水果成篮
https://leetcode.cn/problems/fruit-into-baskets/description/

``` cpp 
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        // 变长划窗中，里面只有2种数;
        unordered_map<int, int> windows;
        int left = 0;
        int valid = 0;
        int n = fruits.size();
        if(n<=2) return n;
        int res = 0;
        for(int right = 0; right < n; right++) {
            // in 
            windows[fruits[right]]++;
            if(windows[fruits[right]] == 1) 
                valid++;
            while(valid > 2) {
                if(windows[fruits[left]] == 1)
                    valid--;
                windows[fruits[left]]--;
                left++;
            }
            res = max(res, right - left + 1);
        }
        return res;
    }
};
```
