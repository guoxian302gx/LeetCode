https://leetcode.cn/discuss/post/3142882/fen-xiang-gun-ti-dan-lian-biao-er-cha-sh-6srp/
* 前序遍历： 顶至下
* 中序：二叉搜索树
* 后： 底至上

底向上： 函数返回值； 比如求树高度； return max(l, r) +1 ;
上到下： 记录一个全局的值; ans不断去更新；这里和归并很像，都是分隔完后，最后去处理。



# 基础遍历题目

* 144. 二叉树的前序遍历
https://leetcode.cn/problems/binary-tree-preorder-traversal/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void preorder(TreeNode* root, vector<int> &res) {
        if(root == NULL) return;
        res.push_back(root->val);
        preorder(root->left, res);
        preorder(root->right, res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == NULL) return {};
        vector<int> res;
        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty()) {
            TreeNode* top = s.top();
            s.pop();
            res.push_back(top->val);
            if(top->right) s.push(top->right);
            if(top->left) s.push(top->left);
        }
        // preorder(root, res);
        return res;
    }
};
```


* 94. 二叉树的中序遍历
https://leetcode.cn/problems/binary-tree-inorder-traversal/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode* root, vector<int> &res) {
        if(root == NULL) return;
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        // inorder(root, res);
        //zuo zhong you
        TreeNode* tmp = root;
        stack<TreeNode*> s;
        while(!s.empty() || tmp != NULL) {
            if(tmp != NULL) {
                s.push(tmp);
                tmp = tmp->left;
                // 这里就是无限左的过程
            } else {
                tmp = s.top(); // 左边为null，这里就是mid了
                s.pop();
                res.push_back(tmp->val); 
                tmp = tmp->right;
            }
        }
        return res;
    }
};
```

* 145. 二叉树的后序遍历
https://leetcode.cn/problems/binary-tree-postorder-traversal/description/
* 因为后续是下往上； 所以其实和 前序是完全逆序的；
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void post(TreeNode* root, vector<int> & res) {
        if(root == NULL) return;
        post(root->left, res);
        post(root->right, res);
        res.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        // post(root, res);
        // zuo you mid
        if(root == NULL) return {};
        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty()) {
            TreeNode* tmp = s.top();
            s.pop();
            res.push_back(tmp->val);
            if(tmp->left) s.push(tmp->left);
            if(tmp->right) s.push(tmp->right);
        }
        int left = 0, right = res.size()-1;
        while(left < right) {
            swap(res[left++], res[right--]);
        }
        return res;
    }
};
```


* 872. 叶子相似的树
https://leetcode.cn/problems/leaf-similar-trees/description/
* 用一样的dfs算法，用vector 记录叶子结点，判断两个树的叶子结点是否一样。
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> in(TreeNode* root) {
        if(root == NULL) return {};
        stack<TreeNode*> s;
        s.push(root);
        vector<int> res;
        while(!s.empty()) {
            TreeNode* tmp = s.top();
            s.pop();
            if(tmp->left == NULL && tmp->right == NULL)
                res.push_back(tmp->val);
            if(tmp->right) s.push(tmp->right);
            if(tmp->left) s.push(tmp->left);
        }
        return res;
    }
    vector<int> mid(TreeNode* root) {
        if(root == NULL) return {};
        stack<TreeNode*> s;
        TreeNode* tmp = root;
        vector<int> res;
        while(!s.empty() || tmp != NULL) {
            if(tmp != NULL) {
                s.push(tmp);
                tmp = tmp->left;
            } else {
                tmp = s.top();
                s.pop();
                if(tmp->left == NULL && tmp->right == NULL)
                    res.push_back(tmp->val);
                tmp = tmp->right;
            }
        }
        return res;
    }
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        // return in(root1) == in(root2);
        return mid(root1) == mid(root2);
    }
};
```

* LCP 44. 开幕式焰火
https://leetcode.cn/problems/sZ59z6/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int numColor(TreeNode* root) {
        unordered_set<int> set;
        if(root == NULL) return 0;
        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty()) {
            TreeNode* tmp = s.top();
            s.pop();
            set.insert(tmp->val);
            if(tmp->right) s.push(tmp->right);
            if(tmp->left) s.push(tmp->left);
        }
        return set.size();
    }
};
```


* 404. 左叶子之和
https://leetcode.cn/problems/sum-of-left-leaves/description/

``` cpp 
左叶子求和 ==> 中序遍历，会一直push左结点；当前左结点不为空，同时为叶子结点的时候，求和；
叶子结点 一定是 left 和 right 都为NULL；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // zuo zhong you  mid
    void dfs(TreeNode* root, int &sum) {
        if(root == NULL) return;
        stack<TreeNode*> s;
        TreeNode* tmp = root;
        while(!s.empty() || tmp != NULL) {
            if(tmp!=NULL) {
                s.push(tmp);
                tmp = tmp->left;
                if(tmp != NULL && tmp->left == NULL && tmp->right == NULL ) sum+=tmp->val;
            } else {
                tmp = s.top();
                s.pop();
                // root;
                tmp = tmp->right;
            }
        }
    }
    int sumOfLeftLeaves(TreeNode* root) {
        int sum = 0;
        dfs(root, sum);
        return sum;
    }
};
```


* 671. 二叉树中第二小的节点
https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/

``` cpp 
>root->val 的 最小值；

题目看清楚；左右结点都比root大；
所以第二小的结点就是 在>root->Val的情况下的最小值；
dfs遍历一次，获取最小值就行；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // dfs-遍历 /前中后都可以
    // 比root->val 大的情况的最小值；
    int findSecondMinimumValue(TreeNode* root) {
        if(root == NULL) return -1;

        long res = LONG_MAX;
        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty()) {
            TreeNode* tmp = s.top();
            s.pop();
            if(tmp->val > root->val) {
                res = min(res, long(tmp->val));
            }
            if(tmp->left) s.push(tmp->left);
            if(tmp->right) s.push(tmp->right);
        }
        if(res == LONG_MAX) return -1;
        return int(res);
    }
};
```


# 前序遍历的dfs
* 有些题目必须前序，有些也可以bfs，有些也可以后续遍历；

104. 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/

``` cpp 
注意这里可以用 下到上、 也可以用上到下的两种遍历方式；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void preorder(TreeNode* root, int depth, int &ans) {
        if(root == NULL) return;
        depth++;
        ans = max(ans, depth); // 维护全局变量，就是树的最大值，depth是当前结点的树高度
        preorder(root->left, depth, ans);
        preorder(root->right, depth, ans);
    }
    int maxDepth(TreeNode* root) {
        // if(root == NULL) return 0;
        // int left = maxDepth(root->left);
        // int right = maxDepth(root->right);
        // return max(left, right) + 1;

        //自上到下
        int ans = 0;
        preorder(root, 0, ans);
        return ans;
    }
};
```

111. 二叉树的最小深度
https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/
``` cpp 
自下到上的求最小深度；
为什么要多root->left == NULL的判断， 如果不做判断，这里会返回left树的高度为0， 但其实是没有子结点，也就没有高度，这是不允许的。
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == NULL) return 0;
        int left = minDepth(root->left);
        int right = minDepth(root->right);
        if(root->left == NULL) return right+1;
        if(root->right == NULL) return left+1;
        return min(left, right) + 1;
    }
};
```


112. 路径总和
https://leetcode.cn/problems/path-sum/description/
``` cpp 
判断是否为叶子结点的时候，对应路径和为0；
自上而下，就是把当前这个结点给处理了。 类比于 push_back(root->val);
对于路径总和。 当前结点的处理就是  root-val == targetSum 且为叶子结点的时候就是答案。
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == NULL) return false;
        if(root->left == NULL && root->right == NULL && root->val == targetSum) {
            return true;
        }
        bool left = hasPathSum(root->left, targetSum - root->val);
        bool right = hasPathSum(root->right, targetSum - root->val);
        return left || right;
    }
};
```


199. 二叉树的右视图
https://leetcode.cn/problems/binary-tree-right-side-view/description/
``` cpp 
1、前序遍历； 变看右子树， 如果depth首次到达res.size(),则把当前结点加入;
2、 层次遍历，记录每层最后一个元素
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void dfs(TreeNode* root, vector<int> &res, int depth) {
        if(root == NULL) return;
        // 先处理当前这个结点，第一次到达这一层；
        if(depth == res.size())
            res.push_back(root->val);
        dfs(root->right, res, depth+1);  // 先递归右子树
        dfs(root->left, res, depth+1);
    }
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        // dfs(root, res, 0);
        if(root == NULL) return {};
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()) {
            int length = q.size();
            for(int i = 0; i < length; i++) {
                TreeNode* tmp = q.front();
                q.pop();
                if(i == length -1) res.push_back(tmp->val);
                if(tmp->left) q.push(tmp->left);
                if(tmp->right) q.push(tmp->right);
            }
        }
        return res;
    }
};
```


1448. 统计二叉树中好节点的数目
https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/
``` cpp 
前序遍历；上到下；
维护一个当前路径下的最大值； 对于当前这个结点>=最大值，res就++
这里的路径肯定是从上到下的， 所以用前序遍历；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void dfs(TreeNode* root, int cur_max, int &res) {
        if(root == NULL) return;
        if(cur_max <= root->val) {
            res++;
            cur_max = root->val;
        }
        dfs(root->left, cur_max, res);
        dfs(root->right, cur_max, res);
    }
    int goodNodes(TreeNode* root) {
        int res = 0;
        dfs(root, INT_MIN, res);
        return res;
    }
};
```


* 1457. 二叉树中的伪回文路径
https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/description/

``` cpp 
有点像回溯了；
前序处理完当前结点后，先走各个方向，然后在reverse回来；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {

public:
    // 偶数为0， 奇数为1
    int cnt[10] = {0};
    bool is_huiwen() {
        // 统计1个数
        int total_1 = 0;
        for(auto c : cnt) {
            if(c == 1)
                total_1++;
        }
        return total_1 <= 1 ? true : false;
    }
    void dfs(TreeNode* root, int &res) {
        if(root == NULL) return;
        cnt[root->val] ^= 1;
        if(root->left == NULL && root->right == NULL && is_huiwen()) {
            res++;
            //is_huiwen ： reduce(p, p+10);
        }
        dfs(root->left, res);
        dfs(root->right, res);
        cnt[root->val] ^= 1;
    }
    int pseudoPalindromicPaths (TreeNode* root) {
        int res = 0;
        dfs(root, res);
        return res;
    }
};
```


* 1315. 祖父节点值为偶数的节点和
https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/description/

``` cpp 
1、前序遍历； 判断当前结点的祖父结点是否为偶数，是的话进行res的累加；
2、构造路径path来记录； path在left和right遍历结束后要pop；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {

public:
    vector<int> nums;
    void dfs(TreeNode* root, int &res) {
        if(root == NULL) return;
        if(nums.size() >= 2 && nums[nums.size()-2] % 2 == 0) {
            res += root->val;
        }
        nums.push_back(root->val);
        dfs(root->left, res);
        dfs(root->right, res);
        nums.pop_back();
    }
    int sumEvenGrandparent(TreeNode* root) {
        int res = 0;
        dfs(root, res);
        return res;
    }
};
```


* 988. 从叶结点开始的最小字符串
https://leetcode.cn/problems/smallest-string-starting-from-leaf/description/

``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string path;
    string reverse(string str) {
        string res = str;
        int left = 0, right = res.size()-1;
        while(left < right) {
            swap(res[left++], res[right--]);
        }
        return res;
    }
    void dfs(TreeNode* root, string &res) {
        if(root == NULL) return;
        path.push_back(root->val + 'a');
        if(root->left == NULL && root->right == NULL) {
            string tmp = reverse(path);
            if(res.empty()) {
                res = tmp;
            } else {
                res = res < tmp ? res : tmp;
            }
        }
        dfs(root->left, res);
        dfs(root->right, res);
        path.pop_back();
    }
    string smallestFromLeaf(TreeNode* root) {
        string res;
        dfs(root, res);
        return res;
    }
};
```

// 解释 为啥全局path 需要在left 和right 后 再pop_back
// 1、因为 path是全局参数；dfs(root->left)后会修改path的路径情况；
// 2、所以要pop回来，在调用dfs(root->right)的时候保持path路径的一致性；
// 3、但是！下面哪个题； 对于 root->left 和 root->right 传进去的是一个定值；left里面不会修改max,min； 所以不用再变回来；


* 1026. 节点与其祖先之间的最大差值
https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/description/
``` cpp 
维护每个结点的最大值和最小值；
最大差值就是 max(res, res-min, res-max);
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
//维护每个结点的最大值&最小值即可
    void dfs(TreeNode* root, int maxx, int minn,int &res) {
        if(root == NULL) return;
        maxx = max(maxx, root->val);
        minn = min(minn, root->val);
        res = max(res, abs(maxx - root->val));
        res = max(res, abs(minn - root->val));
        dfs(root->left, maxx, minn, res);
        dfs(root->right, maxx, minn, res);
    }
    int maxAncestorDiff(TreeNode* root) {
        int res = 0;
        dfs(root, root->val, root->val, res);
        return res;
    }
};
```

* 623. 在二叉树中增加一行
https://leetcode.cn/problems/add-one-row-to-tree/description/

``` cpp 
用前序配合树的深度，当树的深度为depth-1的时候，先插入一行，接着遍历；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    void dfs(TreeNode* root, int cur_depth, const int val, const int depth) {
        if(root == NULL) return;
        cur_depth++;
        if(cur_depth == depth-1) {
            TreeNode* left = new TreeNode(val);
            TreeNode* right = new TreeNode(val);
            left->left = root->left;
            right->right = root->right;
            root->left = left;
            root->right = right;
        }
        ans = max(ans, cur_depth);
        dfs(root->left, cur_depth, val, depth);
        dfs(root->right, cur_depth, val, depth);
    }
    TreeNode* addOneRow(TreeNode* root, int val, int depth) {      
        if(depth == 1) 
        {
            TreeNode* res = new TreeNode(val);
            res->left = root;
            return res;
        }
        dfs(root, 0, val, depth);
        return root;
    }
};
```


# 自底向上

* 104. 二叉树的最大深度
 https://leetcode.cn/problems/maximum-depth-of-binary-tree/

 ``` cpp 
 /**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* root) {
        if(root == NULL) return 0;
        int l = dfs(root->left);
        int r = dfs(root->right);
        return max(l, r) + 1;
    }
    void dfs(TreeNode* root, int depth, int &ans) {
        if(root == NULL) return;
        depth++;
        ans = max(ans, depth);
        dfs(root->left, depth, ans);
        dfs(root->right, depth, ans);
    }
    int maxDepth(TreeNode* root) {
        // return dfs(root);
        int ans = 0;
        dfs(root, 0, ans);
        return ans;

    }
};
 ```


* 111. 二叉树的最小深度
 https://leetcode.cn/problems/minimum-depth-of-binary-tree/submissions/670979435/
 ``` cpp 
 /**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    int minDepth(TreeNode* root) {
        if(root == NULL) return 0;
        if(root->left == NULL) return minDepth(root->right) + 1;
        if(root->right == NULL) return minDepth(root->left) + 1;
        int l = minDepth(root->left);
        int r = minDepth(root->right);
        return min(l, r) + 1;
    }
};
 ```

 * 965. 单值二叉树
https://leetcode.cn/problems/univalued-binary-tree/description/

``` cpp 
底向上： 函数返回值； 比如求树高度； return max(l, r) +1 ;
上到下： 记录一个全局的值; ans不断去更新；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 底至上；
    bool dfs(TreeNode* root, int &val) {
        if(root == NULL) return true;
        bool left = dfs(root->left, val);
        bool right = dfs(root->right, val);
        if(root->val != val) return false;
        return left && right;
    }
    // 上到下
    void dfs(TreeNode* root, bool &res, int & val){
        if(root == NULL) return;
        if(root->val != val) res = false;
        dfs(root->left, res, val);
        dfs(root->right, res, val);
    }
    bool isUnivalTree(TreeNode* root) {
        if(root == NULL) return true;
        int val = root->val;

        // return dfs(root, val);

        bool res = true;
        dfs(root, res, val);
        return res;
    }
};
```

* 100. 相同的树
https://leetcode.cn/problems/same-tree/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 底向上； 函数需要直接返回bool；
    // 也可以构造一个 上到下的 新dfs；
    void dfs(TreeNode* p, TreeNode* q, bool &res) {
        if(p == NULL && q == NULL) return;
        if(p == NULL || q == NULL) {
            res = false; 
            return;
        }
        if(p->val != q->val) res = false;
        dfs(p->left, q->left, res);
        dfs(p->right, q->right, res);
    }
    bool isSameTree(TreeNode* p, TreeNode* q) {
        
        // if(p == NULL && q == NULL) return true;
        // if(p == NULL) return false;
        // if(q == NULL) return false;
        // int l = isSameTree(p->left, q->left);
        // int r = isSameTree(p->right, q->right);
        // if(p->val != q->val ) return false;
        // return l && r;

        bool res = true;
        dfs(p, q, res);
        return res;
    }
};
```

* 101. 对称二叉树
https://leetcode.cn/problems/symmetric-tree/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // pre
    void dfs(TreeNode* left, TreeNode* right, bool & res) {
        if(left == NULL && right == NULL) return;
        if(left == NULL || right == NULL) {
            res = false;
            return;
        }
        if(left->val != right->val) res = false;
        dfs(left->left, right->right, res);
        dfs(left->right, right->left, res);
    }
    bool post(TreeNode* p, TreeNode* q) {
        if(p == NULL && q == NULL) return true;
        if(p == NULL || q == NULL) return false;
        bool left = post(p->left, q->right);
        bool right = post(p->right, q->left);
        if(p->val != q->val) return false;
        return left && right;
    }
    bool isSymmetric(TreeNode* root) {
        // bool res = true;
        // dfs(root, root, res);
        // return res;

        // post
        return post(root, root);

    }
};
```


* 951. 翻转等价二叉树
https://leetcode.cn/problems/flip-equivalent-binary-trees/description/

``` cpp 
1、要么 left = root1->left, root2->left; right = root1->right, root2->right;
2、 要么 left = root1->left, root2->right;  right = root1->right, root2->left;
这两种配对有一种成立即可； 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if(root1 == NULL && root2 == NULL) return true;
        if(root1 == NULL || root2 == NULL) return false;
        
        bool left1 = flipEquiv(root1->left, root2->left);
        bool right1 = flipEquiv(root1->right, root2->right);

        bool left2 = flipEquiv(root1->left, root2->right);
        bool right2 = flipEquiv(root1->right, root2->left);
        if(root1->val != root2->val) return false;
        return (left1 && right1) || (left2 && right2);
    }
};
```


* 110. 平衡二叉树
https://leetcode.cn/problems/balanced-binary-tree/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* root, bool & res) {
        if(root == NULL) return 0;
        int left = dfs(root->left, res);
        int right = dfs(root->right, res);
        if(abs(left-right)>1)
            res = false;
        return max(left, right) + 1;
    }
    bool isBalanced(TreeNode* root) {
        bool res = true;
        dfs(root, res);
        return res;
    }
};
```

* 226. 翻转二叉树
https://leetcode.cn/problems/invert-binary-tree/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL) return NULL;
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        root->left = right;
        root->right = left;
        return root;
    }
};
```

* 617. 合并二叉树
https://leetcode.cn/problems/merge-two-binary-trees/description/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1 == NULL && root2 == NULL) return NULL;
        if(root1 == NULL ) return root2;
        if(root2 == NULL) return root1;
        TreeNode* left = mergeTrees(root1->left, root2->left);
        TreeNode* right = mergeTrees(root1->right, root2->right);
        TreeNode* root = new TreeNode(root1->val + root2->val);
        root->left = left;
        root->right = right;
        return root;
    }
};


# 中序遍历
二叉搜索树较多；

* 700. 二叉搜索树中的搜索
https://leetcode.cn/problems/search-in-a-binary-search-tree/description/
``` cpp 
有点像前序遍历；
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == NULL) return NULL;
        if(root->val == val) return root;
        if(root->val < val) {
            return searchBST(root->right, val);
        } else {
            return searchBST(root->left, val);
        }
    }
};
```

* 530. 二叉搜索树的最小绝对差
https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/

``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void mid(TreeNode* root, int & last, int &res) {
        if(root == NULL) return;
        mid(root->left, last, res);
        if(last == -1) {
            last = root->val;
        } else {
            res = min(res, abs(root->val - last));
            last = root->val;
        }
        mid(root->right, last, res);
    }
    int getMinimumDifference(TreeNode* root) {
        int last = -1;
        int res = INT_MAX;
        mid(root, last, res);
        return res;
    }
};
```

* 938. 二叉搜索树的范围和
https://leetcode.cn/problems/range-sum-of-bst/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void mid(TreeNode* root, const int low, const int high, int &res) {
        if(root == NULL) return;
        mid(root->left, low, high, res);
        if(root->val >= low && root->val <= high)
            res += root->val;
        mid(root->right, low, high, res);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        int res = 0;
        mid(root, low, high, res);
        return res;
    }
};
```

* 98. 验证二叉搜索树
https://leetcode.cn/problems/validate-binary-search-tree/description/
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void dfs(TreeNode* root, long left, long right, bool & res){
        if(root == NULL) return;
        if(left >= root->val || root->val >= right) 
            res = false;
        dfs(root->left, left, root->val, res);
        dfs(root->right,root->val, right, res);
    }
    bool isValidBST(TreeNode* root) {
        bool res = true;
        dfs(root, LONG_MIN, LONG_MAX, res);
        return res;
    }
};
```


# leecode hot 100
* 94. 二叉树的中序遍历
https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void mid(TreeNode* root, vector<int> &res) {
        if(root == NULL) return;
        mid(root->left ,res);
        res.push_back(root->val);
        mid(root->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        // mid(root, res);
        stack<TreeNode*> s;
        TreeNode* tmp = root;
        while(!s.empty() || tmp != NULL) {
            if(tmp != NULL) {
                s.push(tmp);
                tmp = tmp->left;
            } else {
                tmp = s.top();
                s.pop();
                res.push_back(tmp->val);
                tmp = tmp->right;
            }
        }
        return res;
    }
};
```

* 104. 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked
``` cpp 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == NULL) return 0;
        int l = maxDepth(root->left);
        int r = maxDepth(root->right);
        return max(l,r)+1;
    }
};
```
