
* 23、相交链表
 https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
// 最终交汇在null，所以null也要到
// 判断 node1==NULL? 而不是node1->next == NULL ? 
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *node1 = headA;
        ListNode *node2 = headB;
        while(node1 != node2) {
            node1 = node1==NULL? headB : node1->next;
            node2 = node2==NULL? headA : node2->next; 
        }
        return node1;
    }
};
```
*  24、反转链表
*  https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked
```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // ListNode* pre = NULL;
        // ListNode *cur = head;
        // while(cur!=NULL) {
        //     ListNode* next = cur->next;
        //     cur->next = pre;
        //     pre = cur;
        //     cur = next;
        // }
        // return pre;
        
        if(head == NULL || head->next == NULL) return head;
        ListNode* ret = reverseList(head->next);
        head->next->next = head; // head下一个节点的next指向head
        head->next = NULL;     // head的next指向null
        return ret;
    }
};
``` 
*  25、判断回文链表
*  https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked
```
class Solution {
public:
    ListNode* reverse(ListNode* node) { 
        if(node == NULL) return NULL;
        ListNode* pre = NULL;
        ListNode* cur = node;
        while(cur!=NULL) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        // ListNode* low = head, *fast = head;
        // while(fast != NULL && fast->next!=NULL) {
        //     low = low->next;
        //     fast = fast->next->next;
        // }
        // ListNode* pre = NULL;
        // while(low!=NULL) {
        //     ListNode* next = low->next;
        //     low->next = pre;
        //     pre = low;
        //     low = next;
        // }
        // fast = head;
        // while(pre!=NULL) {
        //     if(fast->val != pre->val) return false;
        //     fast =fast->next;
        //     pre = pre->next;
        // }
        // return true;


            // // 1、 借助数组，用双指针
        // if(head == NULL) return true;
        // vector<int> res;
        // ListNode *node = head;
        // while(node!=NULL) {
        //     res.push_back(node->val);
        //     node = node->next;
        // }
        // int left = 0, right = res.size()-1;
        // while(left<right) {
        //     if(res[left++] != res[right--]) return false;
        // }
        // return true;

        // 2、翻转链表，奇数偶数可以一起考虑，注意判断条件是 ！=slow
        //  1）快慢指针找中点
        //  2）翻转 中点的后半段
        if(head == NULL) return true;
        ListNode *slow = head, *fast = head;
        while(fast!=NULL && fast->next !=NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode* tailnode = reverse(slow);  //翻转链表，返回旧链表的尾结点
        ListNode* tailnode2 = tailnode; // 用于再翻转回来
        ListNode* headnode = head;
        while(headnode != slow) {
            if(headnode->val != tailnode->val) return false;
            headnode = headnode->next;
            tailnode = tailnode->next;
        }
        ListNode* tailnode3 = reverse(tailnode2);
        return true;
    }
};
```


*  26、环形链表
*  https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == NULL || head->next == NULL) return false;
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast!=NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow==fast) return true;
        }
        return false;
    }
};
```
* 27、环形链表2
* https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(head == NULL || head->next ==NULL) return NULL;
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast!= NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) break;
        }
        if(fast == NULL || fast->next == NULL) return NULL;
        slow = head;
        while(slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```

*  28、合并2个有序链表
*  https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked
```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1 == NULL) return list2;
        if(list2 == NULL) return list1;
        ListNode* dummy = new ListNode();
        ListNode* node = dummy;
        ListNode* node1 = list1;
        ListNode* node2 = list2;
        while(node1 != NULL && node2 != NULL) {
            if(node1->val >= node2->val) {
                node->next = node2;
                node2 = node2->next;
            } else {
                node->next = node1;
                node1 = node1->next;
            }
            node = node->next;
        }
        if(node1 != NULL) node->next = node1;
        if(node2 != NULL) node->next = node2;
        return dummy->next;
    }
};
```
*  29、 两数相加
*  https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int flag = 0;
        if(l1 == NULL) return l2;
        if(l2 == NULL) return l1;
        ListNode* node1 = l1;
        ListNode* node2 = l2;
        ListNode* dummy = new ListNode();
        ListNode* cur = dummy;
        while(node1 && node2) {
            int val = (node1->val + node2->val + flag) % 10;
            flag = (node1->val + node2->val + flag) / 10;
            cur->next = new ListNode(val);
            cur = cur->next;
            node1 = node1->next;
            node2 = node2->next;
        }
        while(node1) {
            int val = (node1->val +  flag) % 10;
            flag = (node1->val + flag) / 10;
            cur->next = new ListNode(val);
            cur = cur->next;
            node1 = node1->next;
        }
        while(node2) {
            int val = (node2->val +  flag) % 10;
            flag = (node2->val + flag) / 10;
            cur->next = new ListNode(val);
            cur = cur->next;
            node2 = node2->next;
        }
        if(flag == 1) cur->next = new ListNode(1);
        return dummy->next;
    }
};
```

*  30、删除倒数第n个节点
*  https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-100-liked
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* slow = dummy;
        ListNode* fast = dummy;
        int i =0;
        while(i<n && fast) {
            fast = fast->next;
            i++;
        }
        if(fast == NULL) return NULL;
        while(fast->next) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummy->next;
    }
};
``` 
*   31、两两交换链表中的节点
*  https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked
```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* pre = dummy;
        ListNode* cur = head;
        while(cur && cur->next) {
            ListNode* next1 = cur->next;
            ListNode* next2 = cur->next->next;

            pre->next = next1;
            next1->next = cur;
            cur->next = next2;

            pre = cur;
            cur = next2;
        }
        return dummy->next;
    }
};
``` 
*  32、K个一组反转链表
*  https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-100-liked

```
class Solution {
public:
    ListNode* reverse(ListNode* head) {
        ListNode* pre = NULL;
        ListNode* cur = head;
        while(cur != NULL) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        // pre、start、end、next 4个节点就行；   start，end 为翻转链表的头和尾
        ListNode* dummy = new ListNode(0, head);
        ListNode* pre = dummy;
        ListNode* end = dummy;
        ListNode* start = head;
        while(end) {
            // while  end  或者 start 都可以 ，用start 更合理
            for(int i = 0; i < k && end; i++) 
                end = end->next;
            if(end == NULL) break;
            ListNode* next = end->next;
            // 上面为4个节点： pre、strat、end、next
            // 下面为新的4个节点
            end->next = NULL;
            pre->next = reverse(start);
            start->next = next;

            pre = start;
            end = pre;
            start = next;
        }
        return dummy->next;
    }
};
``` 
*  33、随机链表的复制
*  https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked
```
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == NULL) return NULL;
        Node *cur = head;
        //先复制next节点
        while(cur != NULL) {
            Node *node = new Node(cur->val);
            Node * next = cur->next;
            cur->next = node;
            node->next = next; 
            cur = next;
        }
        //在复制random节点
        cur = head;
        while (cur!=NULL) {
            if(cur->random == NULL) {
                cur->next->random = NULL;  //本来就是null，也可以不要
            } else {
                cur->next->random = cur->random->next;
            }
            cur = cur->next->next;
        }
        //断开节点
        cur = head; 
        Node *res = head->next;
        while(cur != NULL && cur->next != NULL) {
            Node* next1 = cur->next;
            Node* next2 = cur->next->next;
            cur->next = next2;
            cur = next1;
        }
        return res;
    }
};
``` 
*  34、排序链表
*  https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // ListNode* sortList(ListNode* head) {
    //     return sortList(head, NULL); // 返回排好序的头结点
    // }
    // 1、自顶向下归并的方式， 空间要 n*log(n)        ,用栈来做无限切分
    // 2、自底向上的归并方式，空间为O（1）          // 用总长度length来做切分
    // ListNode* sortList(ListNode* head, ListNode* tail) {
    //     if(head == NULL) return NULL;
    //     // 因为找中间节点的过程中，是双指针实现呈现左闭右开的形式，所以head->next ==tail，实际上就只有一个节点
    //     if(head->next == tail) {
    //         head->next = NULL;
    //         return head;
    //     }
    //     ListNode* slow = head, *fast = head;
    //     while(fast != tail) {
    //         slow = slow->next;
    //         fast = fast->next;
    //         if(fast!=tail) fast = fast->next;
    //     }
    //     ListNode* mid = slow;
    //     return merge(sortList(head, mid), sortList(mid, tail)); // 两个排好序的链表，merge到一起
    // }
    // ListNode* merge(ListNode*head1, ListNode*head2) {
    //     ListNode* dummy = new ListNode(0);
    //     ListNode* tmp = dummy, *tmp1 = head1, *tmp2 = head2;
    //     while(tmp1!=NULL && tmp2!=NULL) {
    //         if(tmp1->val <= tmp2->val) {
    //             tmp->next = tmp1;
    //             tmp1 = tmp1->next;
    //         } else {
    //             tmp->next = tmp2;
    //             tmp2 = tmp2->next;
    //         }
    //         tmp = tmp->next;
    //     }
    //     if(tmp1 != NULL) tmp->next = tmp1;
    //     if(tmp2 != NULL) tmp->next = tmp2;
    //     return dummy->next;
    // }

    //2、 自底向上的方式
    // 1)获取链表长度
    // 2)从sublength=1 开始merge。 
    // 3)截取cur后的2个list，做一次merge
    // ListNode* sortList(ListNode* head) {
    //     if(head == NULL) return NULL;
    //     int length = 0; 
    //     ListNode* node = head;
    //     while(node != NULL) {
    //         length++;
    //         node = node->next;
    //     }
    //     int sublength = 1;
    //     ListNode * dummy = new ListNode(0, head);
    //     for(; sublength<length; sublength*=2) {
    //         ListNode* pre = dummy, *cur = dummy->next;
    //         while(cur != NULL) {
    //             // 截取两个list,每一个list的末尾不能为null
    //             // 1、截取序列1， 尾断开
    //             ListNode* head1 = cur;
    //             for(int i = 1; i<sublength && cur->next!=NULL; i++)
    //                 cur = cur->next;
    //             ListNode* head2 = cur->next;
    //             cur->next = NULL;

    //             //截取序列2，尾断开， 记录next
    //             cur = head2;
    //             for(int i = 1; i < sublength && cur!=NULL && cur->next !=NULL; i++)
    //                 cur = cur->next;
    //             ListNode *next = NULL;
    //             if(cur != NULL) {
    //                 next = cur->next;
    //                 cur->next = NULL;
    //             }

    //             ListNode *merged = merge(head1, head2);
    //             pre->next = merged;
    //             while (pre->next != NULL) {  // while循环，找到尾节点
    //                 pre = pre->next;
    //             }
    //             cur = next;
    //         }
    //     }
    //     return dummy->next;
    // }
    // ListNode* merge(ListNode *head1, ListNode *head2) {
    //     ListNode* dummy = new ListNode(0);
    //     ListNode* tmp = dummy, *tmp1 = head1, *tmp2 = head2;
    //     while(tmp1!=NULL && tmp2!=NULL) {
    //         if(tmp1->val <= tmp2->val) {
    //             tmp->next = tmp1;
    //             tmp1 = tmp1->next;
    //         } else {
    //             tmp->next = tmp2;
    //             tmp2 = tmp2->next;
    //         }
    //         tmp = tmp->next;
    //     }
    //     if(tmp1!=NULL) tmp->next = tmp1;
    //     if(tmp2!=NULL) tmp->next = tmp2;
    //     return dummy->next;
    // }

    // // 2-test 自底向上
    // ListNode* sortList(ListNode* head) {
    //     if(head == NULL) return NULL;
    //     int length = 0, sublength = 1;
    //     ListNode * tmp = head;
    //     while(tmp != NULL) {
    //         tmp = tmp->next;
    //         length++;
    //     }
    //     ListNode* dummy = new ListNode(0, head);
    //     while(sublength < length) {
    //     // for(; sublength<length; sublength*=2) {
    //         // ListNode *pre = dummy;
    //         // ListNode *cur = head; //这里不能用head， 因为下一次循环开始cur 就不是head了，比如[4213] 下一次就是[2413]
    //         ListNode* pre = dummy, *cur = dummy->next;
    //         while(cur != NULL) {
    //             //截取2个片段
    //             //merge
    //             //更新cur

    //             ListNode* head1 = cur;
    //             for(int i = 1; i < sublength && cur != NULL && cur->next!=NULL; i++) 
    //                 cur = cur->next;
    //             ListNode* head2 = NULL;
    //             if(cur!=NULL) {
    //                 head2 = cur->next;
    //                 cur->next = NULL;
    //             }

    //             cur = head2;
    //             for(int i = 1; i<sublength && cur!=NULL && cur->next!=NULL; i++) 
    //                 cur = cur->next;
    //             ListNode* next = NULL;
    //             if(cur!=NULL) {
    //                 next = cur->next;
    //                 cur->next = NULL;
    //             }

    //             // 更新pre和cur
    //             pre->next = merge(head1, head2);
    //             cur = next;
    //             while(pre->next!=NULL) {
    //                 pre = pre->next;
    //             }
                
    //         }
    //         sublength *= 2;
    //     }
    //     return dummy->next;
    // }

    // ListNode* merge(ListNode* head1, ListNode* head2) {
    //     ListNode * dummy = new ListNode(0);
    //     ListNode * cur = dummy, *node1 = head1, *node2 = head2;
    //     while(node1!=NULL && node2!=NULL) {
    //         if(node1->val <= node2->val) {
    //             cur->next = node1;
    //             node1 = node1->next;
    //         } else {
    //             cur->next = node2;
    //             node2 = node2->next;
    //         }
    //         cur = cur->next;
    //     }
    //     if(node1 != NULL) cur->next = node1;
    //     if(node2 != NULL) cur->next = node2;
    //     return dummy->next;
    // }

    // 3 自底向上
    ListNode* sortList(ListNode* head) {
        if(head == NULL) return NULL;
        int length = 0, sublength = 1;
        ListNode * tmp = head; 
        while(tmp != NULL) {
            length++;
            tmp = tmp->next;
        }
        ListNode * dummy = new ListNode(0, head);
        
        while(sublength<length) {
            ListNode * pre = dummy;
            ListNode* cur = dummy->next; // 这里不能用head； head会变的
            while(cur != NULL) {
                ListNode * head1 = cur;
                // cur 是要入l1 和 l2的，如果cur为null，  cur到这个节点为止，l2直接为null
                for(int i = 1; i < sublength && cur!=NULL && cur->next!=NULL; i++) 
                    cur = cur->next;
                ListNode * next = NULL;
                // 节点够的情况下，判断当前list下最后一个节点是否为null，要断尾取null
                if(cur!=NULL) {
                    next = cur->next;
                    cur->next = NULL;
                }

                //cur 要切换回来，之前断开了
                ListNode * head2 = next;
                cur = next;
                for(int i = 1; i < sublength && cur!=NULL && cur->next!=NULL; i++) 
                    cur = cur->next;
                ListNode *next2 = NULL;
                if(cur!=NULL) {
                    next2 = cur->next;
                    cur->next = NULL;
                }
                pre->next = merge(head1, head2);
                while(pre->next!=NULL)
                    pre = pre->next;
                cur = next2;
            }
            sublength *= 2;
        }
        return dummy->next;
    }
    ListNode * merge(ListNode* head1, ListNode* head2) {
        ListNode * dummy = new ListNode(0);
        ListNode * tmp = dummy;
        ListNode* node1 = head1, *node2 = head2;
        while(node1!=NULL && node2!=NULL) {
            if(node1->val < node2->val) {
                tmp->next = node1;
                tmp = tmp->next;
                node1 = node1->next;
            }else {
                tmp->next = node2;
                tmp = tmp->next;
                node2 = node2->next;
            }
        }
        if(node1!=NULL) tmp->next = node1;
        if(node2!=NULL) tmp->next = node2;
        return dummy->next;
    }

};
``` 
*  35、合并k个升序链表【归并】
*  https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* merge_two(ListNode* list1, ListNode* list2) {
        if(list1 == NULL) return list2;
        if(list2 == NULL) return list1;

        ListNode * dummy = new ListNode();
        ListNode * cur = dummy; 
        ListNode * l1 = list1;
        ListNode * l2 = list2;
        while(l1 && l2) {
            if(l1->val <= l2->val) {
                cur->next = l1;
                l1 = l1->next;
            } else {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        if(l1) cur->next = l1;
        if(l2) cur->next = l2;
        return dummy->next;
    }
    // ans1: 逐个合并
    // ListNode* mergeKLists(vector<ListNode*>& lists) {
    //     ListNode * res = NULL;
    //     for(int i = 0; i < lists.size(); i++) {
    //         res = merge_two(res, lists[i]);
    //     }
    //     return res;
    // }

    // ans2: 两两合并
    ListNode * merge(vector<ListNode*>& lists, int left, int right) {
        if(left == right) return lists[left];
        if(left > right) return NULL;
        int mid = (left + right) >> 1;
        // ListNode * l = merge(lists, left, mid);
        // ListNode * r = merge(lists, mid+1, right);
        // return merge_two(l, r);   // 当前步的结果 为  l 和 r

        return merge_two(merge(lists, left, mid), merge(lists, mid+1, right)); 
        // 等比于跳楼梯 f(n) = f(n-1) + f(n-2); 
        // merge这个函数就是代表 LISTS的left到mid 已经排好序了，只需要这2个merge一下
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size()-1);
    }
};
``` 
