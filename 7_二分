
---------------------
ã€å¥¥ç§˜ã€‘
0ã€ åŒºé—´åˆ†æˆ3éƒ¨åˆ†ï¼Œ = < >  ä¾æ¬¡çœ‹
    å…¶ä¸­ä¸€å®šæœ‰2ä¸ªåŒºé—´çš„æ”¶çª„æ–¹å¼æ˜¯ä¸€æ ·çš„ [mid, mid-1] ã€[mid+1, mid] è¿™ä¸¤ç§æ–¹å¼    
    left = mid + 1; å’Œ right = mid; while(left < right) é€€å‡ºå¾ªç¯ä»¥å left == right æˆç«‹ï¼Œæ­¤æ—¶ mid ä¸­é—´æ•°æ­£å¸¸ä¸‹å–æ•´å°±å¥½ï¼›
    left = mid; å’Œ right = mid - 1; while(left < right) é€€å‡ºå¾ªç¯ä»¥å left == right æˆç«‹ï¼Œæ­¤æ—¶ä¸ºäº†é¿å…æ­»å¾ªç¯ï¼Œmid ä¸­é—´æ•°éœ€è¦æ”¹æˆä¸Šå–æ•´ã€‚
1ã€while(left < right)
    æ­¤æ—¶è·³å‡ºè®­ç»ƒæ—¶å€™  left == rightçš„ï¼Œå¹¶ä¸”leftè¿™ä¸ªç´¢å¼•å€¼æ²¡æœ‰åšåˆ¤æ–­ï¼Œæ‰€ä»¥è¦é¢å¤–åˆ¤æ–­leftçš„å€¼æ˜¯å¦ç¬¦åˆé¢„æœŸ
    1ï¼‰è·³å‡ºå¾ªç¯ï¼Œ left == right æ²¡æœ‰åšåˆ¤æ–­ã€‚ ä¸¤ä¸ªæªæ–½
        1ï¼‰åˆ¤æ–­left==n æ˜¯å¦è¶Šç•Œï¼Œè¶Šç•Œç›´æ¥ä¸æ»¡è¶³
        ã€æœ‰çš„é¢˜ç›®ä¸€å®šå­˜åœ¨idxï¼Œæœ‰çš„ä¸ä¸€å®šå­˜åœ¨ã€‘
        2ï¼‰æ²¡æœ‰è¶Šç•Œçš„æƒ…å†µä¸‹ï¼Œä¸€å®šæ˜¯æ»¡è¶³æ¡ä»¶çš„æ•°äº†ï¼Œç›´æ¥è¿”å›left
                        ï¼Œä¸ä¸€å®šå­˜åœ¨æ—¶å€™ï¼Œæ¯”å¦‚è¦æ‰¾>=targetçš„ç¬¬ä¸€ä¸ªæ•°ï¼Œé‚£ä¹ˆleftå’Œtarget
        ---------------------
        3ï¼‰ åªæ˜¯è¦é¢å¤–åˆ¤æ–­æ˜¯å¦=ï¼ˆæ¯”å¦‚å¯»æ‰¾numsä¸­ç¬¬ä¸€ä¸ª>=targetçš„æ•°ï¼Œå¯èƒ½æ²¡æœ‰=çš„æƒ…å†µï¼‰ï¼Œ
        4ï¼‰ æ‰€ä»¥è¦ç”¨ifï¼Œåˆ¤æ–­æ˜¯å¦=ï¼Œåæ­£å½“å‰left å°±æ˜¯>= çš„æ•°
2ã€ right = n å’Œ  right=n-1çš„é—®é¢˜
    æ­é…å¥¥ç§˜1ä¸€èµ·çœ‹ï¼Œå¦‚æœå¾ªç¯ç»ˆæ­¢æ˜¯ left < rightï¼Œ åŒæ—¶right=nï¼Œ é‚£ä¹ˆä¼šå‡ºç° left = right = nçš„æƒ…å†µï¼Œ
        å…ˆåˆ¤æ–­ left æ˜¯å¦ä¸ºnï¼Œ 
        ä¸ä¸ºnçš„æ—¶å€™åˆ¤æ–­leftå¯¹åº”å€¼æ˜¯å¦ç¬¦åˆé¢„æœŸ
3ã€ ä¸€æ—¦å‡ºç° è¾¹ç•Œç¼©å‡ä¸º [mid, mid-1]çš„ç»„åˆï¼Œ å› ä¸ºmidæ˜¯å‘ä¸‹å–æ•´ï¼Œä¼šå¾ªç¯hangæ­»ï¼Œä¸¤ç§å¤„ç†æ–¹å¼
    1ï¼‰ mid çš„æ—¶å€™å‘ä¸Šå–æ•´ï¼›  
    2ï¼‰ æ¯”å¦‚åªå‰©ä¸‹ä¸¤ä¸ªå…ƒç´ ï¼Œ[left, right]  mid ä¸€ç›´æ˜¯å‘ä¸‹å–æ•´ï¼Œå°±ä¸€ç›´æ˜¯left=leftçš„æƒ…å†µï¼Œå°±hangæ­»äº†
    3) åä¹‹ å¯¹äº left = mid + 1; right = mid; è¿™ç§å‘ä¸‹å–æ•´å°±æ²¡æœ‰é—®é¢˜ï¼›

4ã€ left == right è·³å‡º æ˜¯å¦éœ€è¦å¤„ç†ï¼š ä¸€å®šå­˜åœ¨çš„æ—¶å€™å°±ä¸å¤„ç†ï¼›
æ¯”å¦‚æ‰¾æœ€å°æ•°ï¼Œä¸€å®šå­˜åœ¨æœ€å°æ•°ã€‚ 
æ‰¾>=targetçš„ä½ç½®ï¼Œå¯èƒ½ä¸å­˜åœ¨ï¼Œè¿™é‡Œå°±éœ€è¦åˆ¤æ–­

{æ—‹è½¬æ•°ç»„}
éœ€è¦åˆ¤æ–­nums[mid]  ?? nums[right] æ‰€ä»¥right = n-1  ï¼Œ ä¸èƒ½è¶Šç•Œ

// ã€ç¬¬ä¸€èŠ‚ã€‘704 äºŒåˆ†æŸ¥æ‰¾ï¼Œ æ‰¾åˆ°å…ƒç´ è¿”å› idxï¼Œ æ²¡æœ‰æ‰¾åˆ°è¿”å›-1
// https://leetcode.cn/problems/binary-search/description/
class Solution {
public:
    // https://suanfa8.com/binary-search
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while(left < right) {   //  left <= rightçš„æ—¶å€™ ä¹Ÿè¦åˆ¤æ–­ï¼Œåˆ¤æ–­idx=leftçš„ä½ç½®, å› ä¸ºmid = (right-left)/2 ï¼Œæ‰€ä»¥å…¶å®æ˜¯å‘ä¸‹å–æ•´
            int mid = left + (right-left)/2;
            if(nums[mid] == target) {
                return mid;
            } else if( nums[mid] < target) {
                left = mid+1;
            } else {
                right = mid-1;
            }
        }
        // while left<rightï¼Œå°±ç›¸å½“äº é€€å‡ºå¾ªç¯çš„æ—¶å€™ idx=left=rightï¼Œ ä½†æ˜¯è¿™ä¸ªä½ç½®æ²¡æœ‰åˆ¤æ–­ï¼Œæ‰€ä»¥éœ€è¦åšä¸€æ¬¡é¢å¤–åˆ¤æ–­ï¼›
        if(nums[left] == target) return left;
        return -1;
    }
};


class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        //  left <= rightçš„æ—¶å€™ ä¹Ÿè¦åˆ¤æ–­ï¼Œåˆ¤æ–­idx=leftçš„ä½ç½®, å› ä¸ºmid = (right-left)/2 ï¼Œæ‰€ä»¥å…¶å®æ˜¯å‘ä¸‹å–æ•´
        // å¦‚æœwhileé‡Œé¢æ˜¯ left< rightï¼Œç›¸å½“äº left = rightä½ç½®æ²¡åˆ¤æ–­ï¼Œ whileåé¢è¦æ¥ä¸€ä¸ªåˆ¤æ–­
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                return mid;
            }
        }
        // if(nums[left] == target) return left; 
        return -1;
    }
};



class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        if(left == nums.size()) return -1;
        if(nums[left] == target) return left;
        return -1;
    }
};


// ã€ç¬¬äºŒèŠ‚ã€‘35 æœç´¢æ’å…¥ä½ç½®
// https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-100-liked
class Solution {
public:
    // https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/?envType=study-plan-v2&envId=top-100-liked
    //https://suanfa8.com/binary-search
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); 
        while(left < right) {
            int mid = left + (right-left)/2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};




-------------------------------------------------------
// ã€ç¬¬äºŒèŠ‚ã€‘34  åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®ï¼Œ ä¸å­˜åœ¨åˆ™è¿”å›[-1, -1]
// https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/
// æœ¬è´¨å°±æ˜¯æ‰¾å·¦è¾¹ç•Œã€å³è¾¹ç•Œ
// æ‰¾å·¦è¾¹ç•Œ  å°±æ˜¯æ‰¾ç¬¬ä¸€ä¸ª>= target å…ƒç´ çš„å€¼ , æ‰€ä»¥< çš„ä¸€å®šä¸æ˜¯ç­”æ¡ˆ
// æ‰¾å³è¾¹ç•Œï¼Œ æ‰¾ç¬¬ä¸€ä¸ª> targetå…ƒç´ çš„å€¼ï¼› æ‰€ä»¥<=çš„ä¸€å®šä¸æ˜¯ç­”æ¡ˆ
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        //å…ˆæ‰¾>=target çš„ç¬¬ä¸€ä¸ªæ•°, å› ä¸ºåŒºé—´æ˜¯0,n æœ‰å¯èƒ½æ•´ä¸ªæ•°ç»„éƒ½<targetï¼Œæ‰€ä»¥åˆå§‹åŒ–ä¸ºnï¼Œä½†æ˜¯å‡ºwhileçš„æ—¶å€™left=rightï¼Œè¦åˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºn
        // å†æ‰¾>targetçš„ ç¬¬ä¸€ä¸ªæ•°
        if(nums.empty()) return {-1,-1};
        vector<int> res;
        int n = nums.size();
        int  left =0, right = n;
        // æ‰¾å·¦è¾¹ç•Œ  å°±æ˜¯æ‰¾ç¬¬ä¸€ä¸ª>= target å…ƒç´ çš„å€¼ , æ‰€ä»¥< çš„ä¸€å®šä¸æ˜¯ç­”æ¡ˆ
        while(left<right){
            int mid = (right-left)/2 + left;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if(left>=n) return {-1,-1};
        if(nums[left] !=target) return {-1,-1}; // æ²¡æœ‰æ‰¾åˆ°è¿™ä¸ªæ•°
        res.push_back(left);

        left =0; 
        right = n;
        // æ‰¾å³è¾¹ç•Œï¼Œ æ‰¾ç¬¬ä¸€ä¸ª> targetå…ƒç´ çš„å€¼ï¼› æ‰€ä»¥<=çš„ä¸€å®šä¸æ˜¯ç­”æ¡ˆ
        while(left<right){
            int mid = (right-left)/2 + left;
            if(nums[mid] <= target) {        // nums[mid] < target & nums[mid] == targetçš„æ—¶å€™ éƒ½ä¸¥æ ¼ä¸ºleft=mid+1
                left = mid+1;
            } else {
                right = mid;
            }
        }
        res.push_back(left-1);
        return res;
    }
};

// ã€ç¬¬äºŒèŠ‚ã€‘35 æœç´¢æ’å…¥ä½ç½®
// https://leetcode.cn/problems/search-insert-position/description/
// ç­‰æ•ˆäº34é¢˜ï¼Œ å¯»æ‰¾ç¬¬ä¸€ä¸ª>=targetçš„å€¼ï¼Œç­‰äº34é¢˜æ‰¾å·¦è¾¹ç•Œ
class Solution {
public:
    // https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/?envType=study-plan-v2&envId=top-100-liked
    //https://suanfa8.com/binary-search
    // -----------------
    // right = nums.size(); 
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); 
        // right = n çš„æ—¶å€™ï¼Œ left < right å‡ºæ¥çš„æ—¶å€™ å°±æ˜¯  left = rightï¼Œ æç«¯æƒ…å†µright = n ï¼› è¿™ä¸ªä¸ç”¨åšåˆ¤æ–­
        while(left < right) {
            int mid = left + (right-left)/2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
--------------------      right = nums.size()-1; 
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        // >= targetçš„ç¬¬ä¸€ä¸ªidx
        // right = n-1 çš„æ—¶å€™ï¼Œ left < right å‡ºæ¥çš„æ—¶å€™å°±æ˜¯  left = rightï¼Œæç«¯æƒ…å†µright = n-1 ï¼› è¿™ä¸ªè¦åšåˆ¤æ–­ï¼Œå±äºæœ‰æ•ˆå…ƒç´ 
        while(left < right) { // å› ä¸º left< right ,æ‰€ä»¥Left == right æ²¡æœ‰åˆ¤æ–­
            int mid = (left+right)/2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else if(nums[mid] == target){
                return mid;
            } else {
                right = mid;
            }
        }
        if(nums[left] < target) return nums.size();
        return left;
    }
};



// ã€ç¬¬äºŒèŠ‚ã€‘69 xçš„å¹³æ–¹æ ¹ ï¼Ÿï¼Ÿ è¿™ä¸ªç­”æ¡ˆè¾ƒæ—©ï¼Œå¯ä»¥ä¼˜åŒ–ä¸€ä¸‹
// åœ¨[0, x] ==> [0, x/2] ä¹‹é—´æ‰¾ç­”æ¡ˆ 
// https://leetcode.cn/problems/sqrtx/description/

class Solution {
public:
    int mySqrt(int x) {
        if(x == 0) return 0;
        if(x == 1) return 1;
        int left = 1;
        int right = x;
        while(left < right) {
            int mid = (right - left +1) / 2 + left;
            // è¾¹ç•Œç¼©å‡ä¸ºmid   mid-1çš„æ—¶å€™ï¼Œç”±äºå‘ä¸‹å–æ•´æ‹¿åˆ°leftï¼Œæ‰€ä»¥ä¼šhangæ­»ï¼Œ[left, left+1]  midä¼šä¸€ç›´æ˜¯left
            // å¤„ç†æ–¹å¼ï¼š 1ï¼‰ mid çš„æ—¶å€™å‘ä¸Šå–æ•´ï¼›   
            if(x / mid == mid) {
                return mid;
            } else if(mid  < x/mid){
                left = mid;
            } else {
                right = mid - 1;
            }
            
        }
        return left;
    }
};

// ã€ç¬¬ä¸‰èŠ‚ã€‘ ï½ã€ç¬¬åèŠ‚ã€‘è¿‡ï¼Œéƒ½æ˜¯ç†è®º


----------------ã€é¢˜å‹1ã€‘---------------------
35. æœç´¢æ’å…¥ä½ç½®
// https://leetcode.cn/problems/search-insert-position/description/

class Solution {
public:
    // https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/?envType=study-plan-v2&envId=top-100-liked
    //https://suanfa8.com/binary-search
    // -----------------
    // right = nums.size(); 
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); 
        // right = n çš„æ—¶å€™ï¼Œ left < right å‡ºæ¥çš„æ—¶å€™ å°±æ˜¯  left = rightï¼Œ æç«¯æƒ…å†µright = n ï¼› è¿™ä¸ªä¸ç”¨åšåˆ¤æ–­
        while(left < right) {
            int mid = left + (right-left)/2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
// --------------------      right = nums.size()-1; 
// class Solution {
// public:
//     int searchInsert(vector<int>& nums, int target) {
//         int left = 0, right = nums.size()-1;
//         // >= targetçš„ç¬¬ä¸€ä¸ªidx
//         // right = n-1 çš„æ—¶å€™ï¼Œ left < right å‡ºæ¥çš„æ—¶å€™å°±æ˜¯  left = rightï¼Œæç«¯æƒ…å†µright = n-1 ï¼› è¿™ä¸ªè¦åšåˆ¤æ–­ï¼Œå±äºæœ‰æ•ˆå…ƒç´ 
//         while(left < right) { // å› ä¸º left< right ,æ‰€ä»¥Left == right æ²¡æœ‰åˆ¤æ–­
//             int mid = (left+right)/2;
//             if(nums[mid] < target) {
//                 left = mid + 1;
//             } else if(nums[mid] == target){
//                 return mid;
//             } else {
//                 right = mid;
//             }
//         }
//         if(nums[left] < target) return nums.size();
//         return left;
//     }
// };


74. æœç´¢äºŒç»´çŸ©é˜µ
// https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-100-liked
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        bool res = false;
        int m = matrix.size();
        int n = matrix[0].size();
        int r = 0, c = n-1;
        while(r < m && c >=0) {
            if(matrix[r][c] == target) {
                return true;
            } else if(matrix[r][c] < target){
                r++;
            } else {
                c--;
            }
        }
        return false;
    }
};


34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®
// https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res;
        // zuo bianjie >= targetçš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int left = 0, right = nums.size(); 
        // left = right = n
        while(left < right) {
            int mid = (left + right) / 2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if(left == nums.size()) return {-1,-1};
        if(nums[left] !=target) return {-1,-1}; // æ²¡æ‰¾åˆ°
        res.push_back(left);
        // å³è¾¹ç•Œï¼Œ > target çš„ç¬¬ä¸€ä¸ªå…ƒç´  idx - 1
        left = 0, right = nums.size();
        while(left < right) {
            int mid = (left + right) / 2;
            if(nums[mid] == target) {
                left = mid + 1;
            } else if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        res.push_back(left-1);
        return res;
    }
};


33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„
// å…ˆä¾æ® mid <=re> right  åˆ†æˆ3ç§æƒ…å†µï¼Œå†æ¯ä¸€ç§æƒ…å†µè®¨è®º leftï¼Œmidï¼Œrightçš„å€¼
// 1ï¼‰ åˆ† nums[mid] ^ nums[right] æƒ…å†µ
// 2) åˆ† nums[mid] \ target\ nums[right] æˆ–nums[left] target nums[mid] qingkuang ï¼Œè¾¹ç•Œç”¨<= >=
// 3) left + right + 1çš„æ‰‹æ³•ï¼Œ ä¸Šä¸‹è¾¹ç•Œé—®é¢˜ï¼Œ æ³¨æ„: å¯ä»¥ç”¨æ”¶ç¼©è¾¹ç•Œæ¥å¤„ç†
// https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked
class Solution {
public:
    // https://suanfa8.com/binary-search/solutions-1/0033-search-in-rotated-sorted-array
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        // å› ä¸ºä¸ŠåŠæ®µæ˜¯ left = mid; right = mid-1çš„æ›´æ–°æ–¹å¼ æ‰€ä»¥ä¼šæ­»å¾ªç¯ï¼Œéœ€è¦right-left+1
        // ä¸‹åŠæ®µåˆæ˜¯left = mid+1, right = midçš„æ›´æ–°æ–¹å¼ï¼Œ ç›¸äº’å†²çªï¼Œ æ‰€ä»¥éœ€è¦åšä¸€ä¸ªå°trick ï¼Œè®©ä¸Šä¸‹ä¸¤ç§ç¼©å‡åŒºé—´çš„æ–¹å¼ä¸€è‡´
        // è¦ä¹ˆè®©ä¸ŠåŠæ®µ ä¸º left = mid +1ï¼Œ è¦ä¹ˆè®© ä¸‹åŠæ®µä¸º right = mid-1;
        // while(left < right) {
        //     int mid = left + (right-left+1) / 2;
        //     if(nums[mid] < nums[right]){
        //         // [mid, right] å•è°ƒåŒºé—´ 
        //         if(nums[mid] <= target && target <= nums[right]){
        //             left = mid;
        //         } else {
        //             right = mid-1;
        //         }
        //     } else {
        //         // [left, mid] å•è°ƒåŒºé—´
        //         // if(nums[left] <= target && target <= nums[mid]) {
        //         // [left, mid] å•è°ƒ [left, mid-1ä¸€å®šä¹Ÿå•è°ƒ]
        //         if(nums[left] <= target && target <= nums[mid-1]) {
        //             right = mid-1;
        //         } else {
        //             left = mid;
        //         }
        //     }
        // }
        // fun1(nums, left, right, target);
        fun2(nums, left, right, target);
        if(nums[left] == target) return left;
        return -1;
    }

    void fun1(vector<int>& nums, int& left , int& right, int target) {
        while(left < right) {
            int mid = left + (right-left+1) / 2;
            if(nums[mid] < nums[right]){
                // [mid, right] å•è°ƒåŒºé—´ 
                if(nums[mid] <= target && target <= nums[right]){
                    left = mid;
                } else {
                    right = mid-1;
                }
            } else {
                // [left, mid] å•è°ƒåŒºé—´
                // if(nums[left] <= target && target <= nums[mid]) {
                // [left, mid] å•è°ƒ [left, mid-1ä¸€å®šä¹Ÿå•è°ƒ]
                if(nums[left] <= target && target <= nums[mid-1]) {
                    right = mid-1;
                } else {
                    left = mid;
                }
            }
        }
    }

    void fun2(vector<int>& nums, int& left , int& right, int target) {
        while(left < right) {
            int mid = left + (right-left) / 2;
            if(nums[mid] < nums[right]){
                // [mid, right] å•è°ƒåŒºé—´ 
                // é‚£ä¹ˆ[mid+1,right]ä¹Ÿä¸€å®šå•è°ƒ
                if(nums[mid+1] <= target && target <= nums[right]){
                    left = mid+1;
                } else {
                    right = mid;
                }
            } else {
                // [left, mid] å•è°ƒåŒºé—´
                if(nums[left] <= target && target <= nums[mid]) {
                    right = mid;
                } else {
                    left = mid+1;
                }
            }
        }
    }
};




81. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ II
// https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/
class Solution {
public:
    // ç±»ä¼¼33é¢˜   https://leetcode.cn/problems/search-in-rotated-sorted-array/submissions/509524264/
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        return fun1(nums, left, right, target);
    }
    bool fun1(vector<int>& nums, int &left, int &right, int target) {
        while(left < right) {
            int mid = left + (right - left+1) / 2 ;
            if(nums[mid] < nums[right]) {
                //[mid, right] ä¸¥æ ¼å•è°ƒéå‡
                if(nums[mid] <= target && target <= nums[right]) {
                    left = mid;
                } else {
                    right = mid - 1;
                }
            } else if ( nums[mid] > nums[right] ){
                //[left, mid] ä¸¥æ ¼å•è°ƒéå‡
                // if(nums[left] <= target && target <= nums[mid]) {
                if(nums[left] <= target && target <= nums[mid-1]) {
                    right = mid-1;
                } else {
                    left = mid;
                }
            } else {  // mid = right ,å³è¾¹ç•Œè‡ªå‡1
                if(nums[right] == target) return true;
                right--;
            }
        }
        if(nums[left] == target) return true;
        return false;
    }
};



4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°
https://leetcode.cn/problems/median-of-two-sorted-arrays/description/
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size();
        int n = nums2.size();
        int len = m + n;
        if((m+n)%2==0) return (hlp(nums1, nums2, len/2) + hlp(nums1, nums2, len/2 + 1))/2.0;  // å¶æ•°
        return hlp(nums1, nums2, len/2 + 1); // å¥‡æ•°
    }

    // è¿”å› nums1 + nums2 ä¸­ çš„ç¬¬kä¸ªæ•°
    int hlp(vector<int>& nums1, vector<int>& nums2, int k) {
        int m = nums1.size();
        int n = nums2.size();
        int idx1 = 0, idx2 = 0;
        while(true) {
            if(idx1 == m) return nums2[idx2+k-1];
            if(idx2 == n) return nums1[idx1+k-1];
            if(k==1) return min(nums1[idx1], nums2[idx2]);

            int newidx1 = min(idx1 + k/2 -1, m-1); // ä¸€è½®è¿‡æ»¤ k/2 -1 ä¸ªæ•°  æ¯”å¦‚ï¼Œk=4ï¼Œ ä¸€è¾¹è¿‡æ»¤1ä¸ªæ•°ï¼Œ k=6ï¼Œ ä¸€è¾¹è¿‡æ»¤2ä¸ªæ•°
            int newidx2 = min(idx2 + k/2 -1, n-1); // ä¸€è½®è¿‡æ»¤ k/2 -1 ä¸ªæ•°
            int pivot1 = nums1[newidx1];
            int pivot2 = nums2[newidx2];
            if(pivot1 < pivot2) {
                k = k - (newidx1 - idx1 + 1);
                idx1 = newidx1 + 1;
            } else {
                k = k - (newidx2 - idx2 + 1);
                idx2 = newidx2 + 1;
            }
        }
    }
};



ã€é¢˜å‹1ã€‘ -------------------------------------------------------- 

35. æœç´¢æ’å…¥ä½ç½®ï¼›
https://leetcode.cn/problems/search-insert-position/description/


class Solution {
public:
    // https://leetcode.cn/problems/search-insert-position/solutions/10969/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/?envType=study-plan-v2&envId=top-100-liked
    //https://suanfa8.com/binary-search
    // -----------------
    // right = nums.size(); 
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); 
        // right = n çš„æ—¶å€™ï¼Œ left < right å‡ºæ¥çš„æ—¶å€™ å°±æ˜¯  left = rightï¼Œ æç«¯æƒ…å†µright = n ï¼› è¿™ä¸ªä¸ç”¨åšåˆ¤æ–­
        while(left < right) {
            int mid = left + (right-left)/2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
// --------------------      right = nums.size()-1; 
// class Solution {
// public:
//     int searchInsert(vector<int>& nums, int target) {
//         int left = 0, right = nums.size()-1;
//         // >= targetçš„ç¬¬ä¸€ä¸ªidx
//         // right = n-1 çš„æ—¶å€™ï¼Œ left < right å‡ºæ¥çš„æ—¶å€™å°±æ˜¯  left = rightï¼Œæç«¯æƒ…å†µright = n-1 ï¼› è¿™ä¸ªè¦åšåˆ¤æ–­ï¼Œå±äºæœ‰æ•ˆå…ƒç´ 
//         while(left < right) { // å› ä¸º left< right ,æ‰€ä»¥Left == right æ²¡æœ‰åˆ¤æ–­
//             int mid = (left+right)/2;
//             if(nums[mid] < target) {
//                 left = mid + 1;
//             } else if(nums[mid] == target){
//                 return mid;
//             } else {
//                 right = mid;
//             }
//         }
//         if(nums[left] < target) return nums.size();
//         return left;
//     }
// };



34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®ã€‚
// https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        //>= target
        vector<int> res;
        int n = nums.size();
        int left = 0, right = n;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if(left == n) return {-1, -1};
        if(nums[left] != target) return {-1,-1};
        res.push_back(left);

        // > target ç¬¬ä¸€ä¸ªå…ƒç´ 
        left = 0;
        right = n;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                left = mid + 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        // if(left == n) return {-1, -1};
        res.push_back(left - 1);
        return res;
    }
};


-----------
153. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ï¼›
// https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n-1;
        while(left < right) {
            int mid = (right-left)/2 + left;
            if(nums[mid] < nums[right]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return nums[left];
    }
};

154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ IIï¼›
// æœ‰ç›¸åŒå…ƒç´ ï¼Œ right--;
// https://suanfa8.com/binary-search/solutions-1/0154-find-minimum-in-rotated-sorted-array-ii
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left < right) {
            int mid = left + (right - left ) / 2;
            if(nums[mid] == nums[right]) {
                right--; // ç›¸ç­‰çš„æ—¶å€™ï¼Œ left å’Œright ä¸¤è¾¹éƒ½æœ‰å¯èƒ½ï¼Œright--å°±è¡Œï¼Œä¸€æ­¥ä¸€æ­¥ç¼©å°
                // å› ä¸ºæ˜¯å’Œå³ä¾§nums[right]æ¯”è¾ƒï¼Œ è¿™ä¸ªright ä¸€å®šå¯ä»¥æ’é™¤ï¼Œ å› ä¸ºmid == rightï¼Œæ‰€ä»¥right--ï¼›
                // å¦‚æœæ˜¯å’Œnums[left] æ¯”è¾ƒçš„è¯ï¼Œ  å°±left++;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            } else if (nums[mid] > nums[right]) {
                left = mid + 1;
            }
        }
        return nums[left];
    }
};


33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ï¼›
// https://leetcode.cn/problems/search-in-rotated-sorted-array/description/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n-1;
        // left mid right 
        // 5 6
        //.    1 2 3 4 4.1 4.2
        // æ‰¾åŠæ®µæœ‰åºæ•°ç»„ï¼Œç„¶ååœ¨æœ‰åºæ•°ç»„é‡Œé¢æ‰¾targetï¼›
        // ç”±äºå‰åŠæ®µ å’Œ ååŠæ®µ ä¸€ä¸ªæ˜¯[mid, mid+1] å’Œ [mid-1,mid]çš„ç»„åˆï¼Œæ‰€ä»¥ååŠæ®µï¼Œç¼©å°1ä¸ªç©ºé—´ï¼›
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < nums[right]) {
                if(nums[mid+1] <= target && target <= nums[right]) {
                    left = mid+1;
                } else {
                    right = mid;
                }
            } else {
                // 1 2 3 4 5 6
                //.             0
                if(nums[left] <= target && target <= nums[mid]) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
        }
        if(nums[left] == target) return left;
        return -1;
    }
};


// -------- æ–¹æ³•2ï¼› 3æ¬¡äºŒåˆ†ï¼Œ å…ˆæ‰¾æœ€å°ï¼Œå‰åŠæ®µã€ååŠæ®µæ‰¾>=
public:
    int search(vector<int>& nums, int target) {

        // æ–¹æ³•äºŒ
        //3æ¬¡äºŒåˆ†ï¼›æœ€å°å€¼ï¼›å‰åŠæ®µï¼›ååŠæ®µï¼›
        int n = nums.size();
        int left = 0, right = nums.size()-1;
        //å…ˆæ‰¾æœ€å°å€¼ï¼›
        while(left < right) {
            int mid = left + (right-left) / 2;
            if(nums[mid] > nums[right]){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        int min = left;

         // >= çš„ç¬¬ä¸€ä¸ªæ•°
        left = 0 ,right = min-1;
        while(left < right)
        {
            int mid = left + (right-left) / 2;
            if(nums[mid] < target){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        // é¢å¤–åˆ¤æ–­leftçš„å…ƒç´  æ˜¯å¦ç›¸ç­‰ã€‚ å‡ºå¾ªç¯åªä¿è¯äº†>=
        if(nums[left] == target) {
            return left;
        }
        // åˆ¤æ–­å³è¾¹ç¬¬ä¸€ä¸ª>=çš„æ•°
        left = min, right = n-1;
        while(left < right) {
            int mid = left + (right-left) / 2;
            if(nums[mid] < target){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if(nums[left] == target) return left;
        return -1;
    }
};

81. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ IIï¼›
https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/
// å’Œ ä¸Šé¢˜åŒºåˆ«ï¼Œ numsä¸­å­˜åœ¨é‡å¤å…ƒç´ ï¼Œ å› æ­¤é’ˆå¯¹é‡å¤å…ƒç´ right-- å³å¯

class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < nums[right]) {
                if(nums[mid+1] <= target && target <= nums[right]) {
                    left = mid+1;
                } else {
                    right = mid;
                }
            } else if (nums[mid] > nums[right]) {
                if(nums[left] <= target && target <= nums[mid]) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            } else {
                if(nums[right] == target) return true;
                right--;
            }
        }
        if(nums[left] == target) return true;
        return false;
    }
};


162. å¯»æ‰¾å³°å€¼ï¼›
// https://suanfa8.com/binary-search/solutions-1/0162-find-peak-element
æ³¨æ„ç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ä¸æƒ³ç­‰ï¼Œæ‰€ä»¥åˆ¤æ–­mid å’Œ mid+1 å…ƒç´ å³å¯
//ä¸€ä¸ªå’Œmid çš„å³è¾¹å…ƒç´ æ¯”è¾ƒï¼Œä¸€ä¸ªå’Œmidçš„å·¦è¾¹å…ƒç´ æ¯”è¾ƒ
// nums[i] != nums[i + 1] æ‰€ä»¥ä¸ç”¨è€ƒè™‘ç­‰äºçš„æƒ…å†µ
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < nums[mid+1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};


class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;
            if(nums[mid-1] > nums[mid]) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        return left;
    }
};


275. H æŒ‡æ•° IIï¼›
https://leetcode.cn/problems/h-index-ii/description/
// æœ¬è´¨å°±æ˜¯æ‰¾ä¸€ä¸ªidxï¼Œ è¦æ±‚ nums[idx] >= (n-1) - idx + 1
// Hæ˜¯è®ºæ–‡æ•°é‡
class Solution {
public:
    int hIndex(vector<int>& citations) {
        // if(citations.size() == 1) return 1;
        int n = citations.size();
        if(citations[n-1] == 0) return 0; // æœ€åä¸€ä¸ªå…ƒç´ ä¸º0ï¼Œç›´æ¥ä¸º0
        // æˆ–è€…æœ€ååŠ nums[left] == 0,  return 0;
        int left = 0, right = n-1;
        while(left < right) {
            int mid = left +(right - left) / 2;
            if(citations[mid] < n - mid) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return n-left;
    }
};


611. æœ‰æ•ˆä¸‰è§’å½¢çš„ä¸ªæ•°
https://leetcode.cn/problems/valid-triangle-number/description/
// ä¸¤å±‚forå¾ªç¯ï¼Œ æ‰¾ >= sum1 + sum2 çš„ç¬¬ä¸€ä¸ªæ•°

class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int res = 0;
        int n = nums.size();
        for(int i = 0; i < n-2; i++) {
            for(int j = i + 1; j < n-1; j++) {
                // æ‰¾åˆ°ç¬¬ä¸€ä¸ª >= ä¸¤è¾¹ä¹‹å’Œçš„ä¸‹æ ‡
                int sum = nums[i] + nums[j];
                int left = j + 1, right = n; // æ³¨æ„right çš„ idx=nï¼Œ å› ä¸ºå¯ä»¥å–åˆ°nï¼Œ
                while(left < right) {
                    int mid = (right - left) / 2 + left;
                    if(nums[mid] < sum) {
                        left = mid + 1;
                    } else if (nums[mid] > sum) {
                        right = mid;
                    } else {
                        right = mid;
                    }
                }
                res += left - j - 1;
                
            }
        }
        return res;
    }
};


658. æ‰¾åˆ° K ä¸ªæœ€æ¥è¿‘çš„å…ƒç´ ï¼›
https://leetcode.cn/problems/find-k-closest-elements/description/
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int n = arr.size();
        int left = 0, right = n - k; // å·¦è¾¹ç•Œå¯èƒ½çš„åŒºé—´ï¼Œåœ¨å·¦è¾¹ç•Œå¯èƒ½çš„åŒºé—´æ‰¾idx, idx+kçš„åŒºé—´æ•°
        // è¿™é‡Œç¡®å®šå·¦è¾¹ç•Œåï¼Œåœˆå®šçš„çª—å£æ˜¯[k+1]çš„å¤§å°ï¼› ä»[k+1]å¤§å°çš„çª—å£é‡Œé¢å»æ‰ä¸€ä¸ªå·¦è¾¹ç•Œæˆ–è€…å³è¾¹ç•Œçš„å€¼ å°±æ˜¯[k]çš„å¤§å°ï¼›
        // xç¦»å³è¾¹è¿‘ï¼š å·¦è¾¹ç•Œä¸€å®šå¯ä»¥æ”¶ç¼©ä¸€ä¸ªã€‚ ã€k+1] -> [k] æ‰€ä»¥å·¦è¾¹ç•Œç‚¹ left -> mid+1
            // çª—å£éœ€è¦å³ç§»,æ‰€ä»¥åŠ¨å·¦è¾¹ç•Œ
        // xç¦»å·¦è¾¹è¿‘ï¼š 
            // çª—å£éœ€è¦å·¦ç§»åŠ¨ï¼Œæ‰€ä»¥åŠ¨å³è¾¹ç•Œï¼›
            // å³è¾¹ç•Œä¸€å®šå¯ä»¥æ”¶ç¼©ä¸€ä¸ªã€‚  åˆ¤æ–­çš„æ˜¯[k+1]çª—å£çš„å·¦å³è·ç¦»ã€‚ä»¥midä¸ºèµ·å§‹ç‚¹çš„ké•¿åº¦çª—å£ä»ç„¶æœ‰å¯èƒ½ï¼Œæ‰€ä»¥right = k;
            // ä¸€å®šä¸èƒ½åœ¨å³ç§»äº†ï¼Œ right = mid; åœ¨å³ç§»åŠ¨çš„è¯ï¼Œxä¼šæ›´é è¿‘
        // å½“xç¦» å·¦è¾¹æ¯”è¾ƒè¿œçš„æ—¶å€™ï¼Œè¦æ”¶ç¼©å·¦è¾¹ç•Œï¼Œæ‰€ä»¥ã€‚left = mid + 1;
        // åä¹‹æ”¶ç¼©å³è¾¹ç•Œ right = mid;
        // ğŸŸ°çš„æ—¶å€™  æ”¶ç¼©å³è¾¹ç•Œï¼Œ å› ä¸ºæ˜¯å­—æ¯åºå°çš„
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(x - arr[mid] > arr[mid + k] - x) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        vector<int> res;
        for(int i = left; i < left + k; i++) {
            res.push_back(arr[i]);
        }
        return res;
    }
};



744. å¯»æ‰¾æ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯ï¼›
https://leetcode.cn/problems/find-smallest-letter-greater-than-target/description/

public class Solution {

    public char nextGreatestLetter(char[] letters, char target) {
        int len = letters.length;
        int left = 0;
        int right = len;
        while (left < right){
            int mid = (left + right) >>> 1;
            if (letters[mid] <= target){
                // ä¸‹ä¸€è½®æœç´¢çš„åŒºé—´æ˜¯ï¼š[mid + 1, right]
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        // å› ä¸ºæœ‰å¯èƒ½ä¸å­˜åœ¨
        if (left == len){
            return letters[0];
        }
        return letters[left];
    }
}


852. å±±è„‰æ•°ç»„çš„å³°é¡¶ç´¢å¼•
https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/
å±±å³°æ•°ç»„æ²¡æœ‰è¿ç»­2ä¸ªå€¼ç›¸ç­‰çš„æƒ…å†µ

class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n = arr.size();
        int left = 0, right = n-2; 
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(arr[mid] > arr[mid+1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
            // arr[mid] == arr[mid+1]çš„æ—¶å€™ï¼Œ left æˆ–è€… right éƒ½å¯ä»¥ç§»åŠ¨
            // if(arr[mid] < arr[mid+1]) {
            //     left = mid + 1;
            // } else {
            //     right = mid;
            // }
        }
        return left; // ä¸€å®šå­˜åœ¨å³°å€¼ï¼Œæ‰€ä»¥ä¸éœ€è¦åˆ¤æ–­ nums[left]æ˜¯ä¸æ˜¯æˆ‘ä»¬æ‰€è¦çš„
    }
};

1095. å±±è„‰æ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼
https://leetcode.cn/problems/find-in-mountain-array/description/
1)å…ˆæ‰¾å³°é¡¶å…ƒç´ 
2ï¼‰ å‰åŠæ®µæ‰¾targetï¼Œ 
3ï¼‰ååŠæ®µæ‰¾target


/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *   public:
 *     int get(int index);
 *     int length();
 * };
 */

class Solution {
public:
    int findInMountainArray(int target, MountainArray &mountainArr) {
        int n = mountainArr.length();
        // MountainArray.get(k)
        int left = 0, right = n-2;
        // 1)æ‰¾å³°å€¼
        right = n -2;
        while(left < right) {
            int mid = left + (right - left) / 2;
            // æ— æ³•ç”¨æ—‹è½¬æ•°æ®ä¸€æ ·çš„æ–¹æ³•
            // æ—‹è½¬æ•°æ®çš„æ¯ä¸€ä¸ªæ•°æœ€å¤šxiangdeng. æ¯”å¦‚ [ 1 2 3 0 1]
            // è€Œå¤šå³° æ˜¯ ã€1 2 3 4 5 3 1ã€‘å¯èƒ½ä¼šæœ‰2ä¸ª3ï¼Œ æ— æ³•ç”¨ midå’Œrightæ¥åˆ¤æ–­ åœ¨midå·¦ä¾§è¿˜æ˜¯å³ä¾§
            
            if(mountainArr.get(mid) <= mountainArr.get(mid+1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        int top = left;
        left = 0, right = top;  // è¿™é‡Œright å¯ä»¥æ¢æˆTop+1 ï¼Œ æ‰¾>=targetçš„ç¬¬ä¸€ä¸ªä½ç½®
        while(left < right) {
            int mid = left + (right - left) / 2;
            // mountainArr.get(mid) == target çš„æ—¶å€™ï¼Œ 
            // left = mid æˆ–è€… right = mid éƒ½å¯ä»¥ï¼Œä½†æ˜¯æ­¤æ—¶left å·²ç» mid+1ï¼Œright = midäº†ï¼Œæ‰€ä»¥å¹¶åˆ° rightå»
            if(mountainArr.get(mid) < target) {
                left = mid+1;
            } else {
                right = mid;
            }
        }
        if(mountainArr.get(left) == target) return left;
        left = top, right = n - 1;  // è¿™ä¸ªåœ°æ–¹å› ä¸ºæ˜¯ ã€Œé€’å‡ã€çš„ æ‰€ä»¥rightä¸èƒ½æ¢æˆ n
        while(left < right) {
            int mid = left + (right - left+1) / 2;
            if(mountainArr.get(mid) < target) {
                right = mid-1;
            } else {
                left = mid;
            }
        }
        if(mountainArr.get(left) == target) return left;
        return -1;
    }
};


int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); 
        // right = n çš„æ—¶å€™ï¼Œ left < right å‡ºæ¥çš„æ—¶å€™ å°±æ˜¯  left = rightï¼Œ æç«¯æƒ…å†µright = n ï¼› è¿™ä¸ªä¸ç”¨åšåˆ¤æ–­
        while(left < right) {
            int mid = left + (right-left)/2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }


        if(nums1.size() > nums2.size()) {
            vector<int> tmp = nums1;
            nums1 = nums2;
            nums2 = tmp;
        }
        int m = nums1.size();
        int n = nums2.size();
        // nums1 ä¸­æ‰¾åˆ‡å‰²ç‚¹
        // å…ƒç´ ä¸ªæ•° m+n+1 / 2
        int cnt = (m + n + 1) / 2;
        int left = 0, right = m;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;
            int idx = cnt - mid;
            if(nums1[mid-1] > nums2[idx]) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        // left ä¸ºåˆ‡å‰²ç‚¹
        // ç‰¹æ®Šæƒ…å†µ
        int idx2 = cnt - left;
        int left1 = left == 0 ? INT_MIN : nums1[left - 1];
        int right1 = left == m ?INT_MAX : nums1[left];

        int left2 = idx2 == 0 ? INT_MIN : nums2[idx2 - 1];
        int right2 = idx2 == n ? INT_MAX : nums2[idx2];

        if((m+n)%2 == 1) {
            return max(left1, left2);
        }
        return (max(left1, left2) + min(right1, right2) ) / 2.0;

4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°
https://leetcode.cn/problems/median-of-two-sorted-arrays/description/
public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        int m = nums1.length;
        int n = nums2.length;
        // åˆ†å‰²çº¿å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ éœ€è¦æ»¡è¶³çš„ä¸ªæ•° m + (n - m + 1) / 2;
        int totalLeft = (m + n + 1) / 2;
        // åœ¨ nums1 çš„åŒºé—´ [0, m] é‡ŒæŸ¥æ‰¾æ°å½“çš„åˆ†å‰²çº¿ï¼Œ
        // ä½¿å¾— nums1[i - 1] <= nums2[j] && nums2[j - 1] <= nums1[i]
        int left = 0;
        int right = m;

        while (left < right) {
            int i = left + (right - left + 1) / 2;
            int j = totalLeft - i;
            if (nums1[i - 1] > nums2[j]) {
                right = i - 1;
            } else {
                left = i;
            }
        }

        int i = left;
        int j = totalLeft - i;

        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
        int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
        int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];

        if (((m + n) % 2) == 1) {
            return Math.max(nums1LeftMax, nums2LeftMax);
        } else {
            return (double) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / 2;
        }
    }

}

// å¦‚æœä¸æŠŠé•¿åº¦çŸ­çš„æ”¾å‰é¢ï¼Œ ä¼šå‡ºç°è¶Šç•Œç­‰è¡Œä¸º
// ã€å…³äºæŠŠçŸ­æ•°ç»„æ”¾å‰é¢ï¼š1ï¼‰æ¯”å¦‚æ•°ç»„é•¿åº¦ä¸º 10ï¼Œ 1 ï¼›    é‚£ä¹ˆä¸€è¾¹è¦åˆ†5ä¸ªæ•°ï¼Œ å½“nums1çš„åˆ†å‰²çº¿å¾ˆå°çš„æ—¶å€™ï¼Œnum2å°±ä¼šå‡ºç°è´Ÿæ•°ã€‘
// ã€åä¹‹å°±ä¸ä¼šï¼Œ å› æ­¤æˆ‘ä»¬å¿…é¡»åœ¨çŸ­çš„æ•°ç»„ä¸Šæœç´¢ iã€‘
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) {
            vector<int> temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        // æ‰¾åˆ†å‰²çº¿  left1 right1.  ;left2 right2;
        // å› ä¸ºåŒä¸€ä¸ªæ•°ç»„ï¼Œæ‰€ä»¥ left1 <= right1 ï¼Œ left2<=right2ï¼Œæ¥ç€è¦ä¿è¯ left1<=right2  left2<=right1;
        // åŒæ—¶åˆ†å‰²çº¿å·¦è¾¹å…ƒç´ ä¸ºä¸­ä½æ•°[idxçš„å·¦è¾¹]ã€‚ã€idxå·¦è¾¹ + idxã€‘ 
        int m = nums1.size();
        int n = nums2.size();
        int length = m + n;
        int total_num = (length + 1)/ 2; // åˆ†å‰²çº¿å·¦è¾¹çš„å…ƒç´ ä¸ªæ•°
        // 0  ~  m æ‰¾åˆ†å‰²çº¿
        int left = 0, right = m;
        while(left < right) {
            int i = left + (right - left + 1) / 2; // nums1 æœ‰ iä¸ªå…ƒç´ [0, i-1]
            int j = total_num - i; // num2 æœ‰ total -i ä¸ªå…ƒç´ [0, j-1] 
            if(nums1[i-1] > nums2[j]) {
                right = i - 1;
            } else {
                left = i;
            }
        }
        int i = left;
        int j = total_num - i;
        int left_max1, left_max2;
        int right_min1, right_min2;
        left_max1 = i == 0?INT_MIN : nums1[i-1];
        right_min1 = i == m?INT_MAX: nums1[i];
        left_max2 = j == 0?INT_MIN : nums2[j-1];
        right_min2 = j == n?INT_MAX: nums2[j];
        if(length%2 == 1) {
            return max(left_max1, left_max2);
        }  else {
            return (max(left_max1, left_max2) + min(right_min1, right_min2)) / 2.0;
        }
    }
    
};




69. x çš„å¹³æ–¹æ ¹ 
https://leetcode.cn/problems/sqrtx/description/

class Solution {
public:
    int mySqrt(int x) {
        if(x == 0) return 0;
        if(x == 1) return 1;
        int left = 1;
        int right = x;
        while(left < right) {
            int mid = (right - left ) / 2 + left;
            // è¾¹ç•Œç¼©å‡ä¸ºmid   mid-1çš„æ—¶å€™ï¼Œç”±äºå‘ä¸‹å–æ•´æ‹¿åˆ°leftï¼Œæ‰€ä»¥ä¼šhangæ­»ï¼Œ[left, left+1]  midä¼šä¸€ç›´æ˜¯left
            // å¤„ç†æ–¹å¼ï¼š 1ï¼‰ mid çš„æ—¶å€™å‘ä¸Šå–æ•´ï¼›   
            if(x / mid == mid) {
                return mid;
            } else if(mid  < x/mid){
                left = mid;
            } else {
                right = mid - 1;
            }
            
        }
        return left;
    }
};


436. å¯»æ‰¾å³åŒºé—´
https://leetcode.cn/problems/find-right-interval/description/
// 1ã€map è®°å½• æ¯ä¸ªåŒºé—´left åœ¨åŸæ•°ç»„çš„idx
// 2ã€sort æ’åºï¼›
// 3ã€ä¾æ¬¡å¯»æ‰¾ interval[i][1] ä½œä¸ºtargetï¼Œ left å’Œright ä¸‹ [interval][x][0] >=targetçš„å€¼ 

cclass Solution {
public:
    vector<int> findRightInterval(vector<vector<int>>& intervals) {
        vector<int> res;

        vector<vector<int>> tmp = intervals;
        int n = intervals.size();

        map<int, int> mp; // key = leftï¼Œ value ä¸ºåŸæ•°ç»„çš„idx
        for(int i = 0; i < n; i++) {
            mp[intervals[i][0]] = i;
        }

        sort(tmp.begin(), tmp.end());

        
        for(int i = 0; i < n; i++) {
            int target = intervals[i][1];
            // sort ä¸­ æ‰¾>= target çš„ leftå…ƒç´ 
            int left = 0, right = n-1;
            while(left < right) {
                int mid = left + (right - left) / 2;
                if(tmp[mid][0] < target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            if(tmp[left][0] >= target) { // è¿™é‡Œé…åˆ right = n-1;// åœˆå®šäº†
            // if(left < n) { // è¿™é‡Œé…åˆ right = n; æœ€åè·³å‡ºå¾ªç¯çš„ä¸€å®šæ˜¯>=targetï¼Œæˆ–è€…è¶Šç•Œ
                res.push_back(mp[tmp[left][0]]);
            } else {
                res.push_back(-1);
            }
        }
        return res;
    }
};


287. å¯»æ‰¾é‡å¤æ•°

https://leetcode.cn/problems/find-the-duplicate-number/description/
ä¸¤ç§æ–¹æ³•ï¼š 
1ã€äºŒåˆ†ï¼› ç”¨æŠ½å±‰åŸåˆ™ï¼›æ•°numä¸­<=midçš„ä¸ªæ•° åº”è¯¥ä¸ºmidä¸ª
2ã€å¿«æ…¢æŒ‡é’ˆï¼Œ O(n);


class Solution {
public:
    int findDuplicate(vector<int>& nums) {

        // æ–¹æ³•1ï¼Œ 0å‡ºå‘çš„ä¸€å®šæœ‰ç¯ï¼› å› ä¸ºæ•°å­—æ˜¯[1,n]ä¹‹é—´ï¼Œæ²¡åŠæ³•æœ‰æ•°æŒ‡å‘0
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);
        slow = 0;
        while(slow != fast ){
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;

        // æ–¹æ³•2
        int n = nums.size();
        int left = 1, right = n-1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            int cnt = 0;
            // æŠ½å±‰åŸç† midä¸ºé—´éš”ï¼Œé‚£ä¹ˆ<=mid çš„æ—¶å€™ï¼Œåº”è¯¥æœ‰midä¸ªï¼Œå·¦è¾¹æ‰ä¸ç¼ºæ•°
            for(auto num : nums) {
                if(num <= mid) cnt++;  // 
            }
            if(cnt > mid) { // cnt> mid, è¯´æ˜ <=midçš„åŒºé—´ï¼ŒæŸä¸ªæŠ½å±‰æ”¾äº†2ä¸ª
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};


378. æœ‰åºçŸ©é˜µä¸­ç¬¬ K å°çš„å…ƒç´ 
https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/
// äºŒåˆ†æŸä¸ªæ•°midï¼›  åˆ¤æ–­æ•°ç»„ä¸­<=midçš„æ•°æ˜¯å¦æœ‰cntä¸ªã€‚
// cnt>=kä¸ªè¯ï¼Œå¯èƒ½ä¸ºç­”æ¡ˆï¼› å¦åˆ™ä¸€å®šä¸æ˜¯ç­”æ¡ˆï¼›
class Solution {
public:
    int GetCount(int target, vector<vector<int>>& matrix) {
        int n = matrix.size();
        int cnt = 0;
        int i = 0, j = n-1;
        while(i<n && j>=0) {
            if(matrix[i][j] <= target) {
                cnt += j+1;
                i++;
            } else {
                j--;
            }
        }
        return cnt;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n = matrix.size();
        int left = matrix[0][0], right = matrix[n-1][n-1];
        while(left < right) {
            int mid = left + (right - left) / 2;
            int cnt = GetCount(mid, matrix); // <= midçš„ä¸ªæ•°
            if(cnt < k) {
                left = mid + 1;
            } else { // >= k 
                right = mid;
            }
        }
        // left å…¶å®æ˜¯>=æŸä¸ªå…ƒç´ çš„æœ€å°æ•°ï¼›
        // æ¯”å¦‚ >=13 < 15 æœ€ç»ˆçš„kéƒ½æ˜¯8ï¼Œ ä½†æ˜¯è¿™ä¸ªå¾ªç¯æ˜¯å¯»æ‰¾>=13çš„13çš„è¿™ä¸ªæ•°çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯13
        return left;
    }
};


875. çˆ±åƒé¦™è•‰çš„ç‚ç‚

https://leetcode.cn/problems/koko-eating-bananas/description/

//äºŒåˆ†é€Ÿåº¦ï¼›
// æ—¶é—´å¤æ‚åº¦ï¼šn * log(n)

class Solution {
public:
    int CntPiles(const vector<int>& piles, const int& cnt) {
        long res = 0;
        for(auto pile : piles) {
            res += (pile + cnt - 1) / cnt;
        }
        return res;
    }
    int minEatingSpeed(vector<int>& piles, int h) {
        int right = 1;
        int left = 1;
        for(auto pile : piles) {
            right = max(right, pile);
        }

        while(left < right) {
            int mid = left + (right - left) / 2;
            int cnt = CntPiles(piles, mid); // è¿”å›éœ€è¦çš„å°æ—¶ï¼Œéœ€è¦<=h
            if(cnt > h) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};



410. åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼

https://leetcode.cn/problems/split-array-largest-sum/description/

// å¯»æ‰¾ä¸€ä¸ªvalueï¼Œ ä½¿å¾—ç”¨value å»åˆ‡åˆ†æ•°ç»„çš„split ä¸ªæ•° <=m ï¼Œå¯ä»¥ç»§ç»­åˆå¹¶ï¼Œ >m ï¼Œ valueä¸€å®šä¸è¡Œï¼›
// åŒºé—´ä¸ªæ•° ç”¨ cnt, cur_sum > thred å» dpè·å–ï¼›

class Solution {
public:
    int SplitCnt(const vector<int>& nums, const int& thred) {
        int cnt = 1;
        int cur = 0;
        for(auto num : nums) {
            if(cur + num > thred) {
                cnt++;
                cur = num;
            } else {
                cur += num;
            }
        }
        return cnt;
    }
    int splitArray(vector<int>& nums, int k) {
        // return SplitCnt(nums,6);
        // æ‰¾ä¸€ä¸ª valueï¼Œåˆ†å‰²numsåï¼Œå­æ•°ç»„ä¸ªæ•°==k
        int left = 0, right = 0;
        for(auto num : nums) {
            left = max(left, num);
            right += num;
        }
        while(left < right) {
            int mid = left + (right - left) / 2;
            int split_cnt = SplitCnt(nums, mid);
            if(split_cnt > k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};


LCP 12. å°å¼ åˆ·é¢˜è®¡åˆ’
https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/description/
// ç±»ä¼¼410
// æœ¬é¢˜æ˜¯æ‰¾ä¸€ä¸ªvalue ï¼Œleft = 0ï¼Œ right = sum(all);
// åˆ‡åˆ†æ•°ç»„ï¼Œ  è®©  æ•°ç»„åŒºé—´å’Œ-åŒºé—´max > thredï¼ŒåŒºé—´ä¸ªæ•°++
// åŒºé—´ä¸ªæ•°è¦ <= ï¼Œ  >çš„è¯ä¸€å®šä¸æˆç«‹

class Solution {
public:
    int SplitCnt(vector<int>& time, const int& threshhold){
        int split_cnt = 1;
        int cur_sum = 0;
        int cur_max = 0;
        for(auto ti : time) {
            cur_max = max(cur_max, ti); 
            if(cur_sum + ti - cur_max > threshhold) {
                split_cnt++;
                cur_sum = ti;
                
                cur_max = ti; // æ–°çª—å£
            } else {
                cur_sum += ti;
            }
        }
        return split_cnt;
    }

    int minTime(vector<int>& time, int m) {
        // return SplitCnt(time, 3)[1];
        // æ‰¾åˆ°ä¸€ä¸ªvalueï¼Œ æŠŠtime åˆ†æˆmå—ï¼› å„å—ä¹‹å’Œæœ€å°ï¼›
        int left = 0;
        int right = 1;
        for(auto ti : time) {
            right += ti;
        }
        int res = right;
        int interval_cnt = m;
        while(left < right) {
            int sum = left + (right - left) / 2;
            // sum splitæˆ å‡ å—
            int split_cnt = SplitCnt(time, sum);
            // å¯ä»¥<= ï¼Œ å¦‚æœ>mçš„è¯ï¼Œ è¿™ä¸ªå€¼è‚¯å®šå°
            if(split_cnt > interval_cnt) {
                left = sum + 1;
            }else {
                right = sum;
            }
        }
        return left;
    }
};


1011. åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ›
https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/

// å’Œä¸Šé¢çš„é¢˜ä¸€æ ·ï¼Œæ³¨æ„left =max(nums) , right = sum(nums)


class Solution {
public:
    int SplitNums(vector<int>& weights, int thred){
        int splits = 1;
        int cur_sum = 0;
        for(auto weight : weights) {
            if(cur_sum + weight > thred) {
                splits++;
                cur_sum = weight;
            } else {
                cur_sum += weight;
            }
        }
        return splits;
    }
    int shipWithinDays(vector<int>& weights, int days) {
        // return SplitNums(weights, 2);
        int left = 1;
        int right = 0;
        for(auto weight : weights) {
            right += weight;
            left = max(left, weight);
        }

        while (left < right) {
            int loads = left + (right - left) / 2;
            // å¯»æ‰¾ä¸€ä¸ªloads å¯ä»¥åˆ‡åˆ†æ•°ç»„ï¼›
            int cnt = SplitNums(weights, loads);
            if(cnt > days) {
                left = loads + 1;
            } else {
                right = loads;
            }
        }
        return left;
    }
};



1283. ä½¿ç»“æœä¸è¶…è¿‡é˜ˆå€¼çš„æœ€å°é™¤æ•°

https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/

class Solution {
public:
    int GetCnt(vector<int>& nums, int value) {
        int res = 0;
        for(auto num : nums) {
            res += (num + value - 1 ) / value;
        }
        return res;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        //   äºŒåˆ†æ‰¾ä¸€ä¸ªæ•° [1, max] 
        int left = 1;
        int right = 1;
        for(auto num : nums) {
            right = max(right, num);
        }
        while (left < right) {
            int value = left + (right - left) / 2;
            int cnt = GetCnt(nums, value);
            if(cnt > threshold) {
                left = value + 1;
            } else {
                right = value;
            }
        }
        return left;
    }
};


1482. åˆ¶ä½œ m æŸèŠ±æ‰€éœ€çš„æœ€å°‘å¤©æ•°
https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/description/


class Solution {
public:
    int GetCnt(vector<int>& bloomDay, int value, int k) {
        int count = 0;
        int res = 0;
        // 1   10 3 10 2
        // idx  
        int last_idx = 0; // å½“å‰çª—å£å¼€å§‹çš„ç´¢å¼•
        for(int i = 0; i < bloomDay.size(); i++){
            if(bloomDay[i] <= value) {
                count++;
            } else {
                count = 0;
                continue;
            }
            // è¿ç»­næœµï¼Œåˆ¶ä½œä¸€æŸèŠ±
            if(count == k) {
                res++;
                count = 0;
            }
        }
        return res;
    }
    int minDays(vector<int>& bloomDay, int m, int k) {
        // return GetCnt(bloomDay, 9,3);
        // [1, max] æ‰¾ä¸€ä¸ªvalue æ¥åˆ‡å‰²ï¼› åˆ‡å‰²æˆnä¸ªå—ï¼›æ¯ä¸ªå—çš„å€¼éƒ½è¦<=value, ä¸”è¿ç»­é•¿åº¦==k
        int left = INT_MAX;
        int right = 1;
        for(auto bloom : bloomDay) {
            right = max(right, bloom);
            left = min(left, bloom);
        }
        while(left < right) {
            int value = left + (right - left) / 2;
            int cnt = GetCnt(bloomDay, value, k);
            
            if (cnt < m) {
                left = value + 1;
            } else {
                right = value;
            }
        }
        // ç‰¹ä¾‹åˆ¤æ–­æœ€åä¸€æ¬¡ï¼› ä¹Ÿå¯ä»¥å‰ç½®åˆ¤æ–­m*k>lençš„æ—¶å€™ï¼Œreturn -1
        int cnt = GetCnt(bloomDay, left, k);
        if(cnt>=m) return left;
        return -1;
    }

};



1552. ä¸¤çƒä¹‹é—´çš„ç£åŠ›
https://leetcode.cn/problems/magnetic-force-between-two-balls/description/
// è¿™é‡Œå…ˆsortï¼Œ è¿™æ ·ç£åŠ›è®¡ç®—å°±ä»å°åˆ°å¤§äº†ï¼Œæ‰¾åˆ°ä¸€ä¸ªç£åŠ›value å»åˆ‡åˆ†æ•°ç»„ï¼› distance >= valueçš„å°±æ˜¯æ–°çš„åˆ‡å‰²ç‚¹;
// cnt < m åˆ‡å‰²å¤ªå°‘ï¼› right=mid-1;
// cnt >= m åˆ‡å‰²è¿˜è¡Œï¼Œ å¯èƒ½æœ‰æ›´å¤§çš„æå€¼ï¼› left = mid;

class Solution {
public:
    int Split(vector<int>& position, int value) {
        // ç¬¬ä¸€ä¸ªçƒç£åŠ›æœ€å°ï¼Œä¸€å®šæ”¾ä¸€ä¸ª
        int res = 1; 
        int last = position[0];
        for(int i = 1; i < position.size(); i++) {
            if(position[i] - last >= value) {
                res++;
                last = position[i];
            }
        }
        return res;
    }
    int maxDistance(vector<int>& position, int m) {
        // å…ˆæ’åºäº†ï¼› è¿™æ ·ç£åŠ›å°±ç¬¦åˆä»å°åˆ°å¤§
        sort(position.begin(), position.end());
        int n = position.size();
        int left = 1;
        int right = position[n-1] - position[0];
        while(left < right) {
            int value = left + (right - left+1) / 2;
            int cnt = Split(position, value); // æ”¾å‡ ä¸ªçƒ
            // < m çƒå¤ªå°‘äº†ï¼Œ ç£åŠ›å¤ªå¤§ï¼›
            // >= m çƒå¤ªå¤šï¼Œ ç£åŠ›å¤ªå°
            if(cnt < m) {
                right = value-1;
            }  else {
                left = value;
            }
        }
        return left;
    }
};
