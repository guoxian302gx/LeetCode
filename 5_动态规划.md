# 动态规划
https://www.bilibili.com/video/BV13Q4y197Wg?spm_id_from=333.788.videopod.sections&vd_source=ed1ae5cbd4ddff5db18d328c25da5b1e
背包问题
打家劫舍
买卖股票
子序列问题

动态规划 五部曲：
dp数组含义
dp 递推公式
dp初始化
遍历顺序
打印dp数组

01:
二维数据，两个for没区别；
一维数据，两个for， for物品，for背包是组合；    for背包、for 物品 是序列； 逆序；
求最大价值 dp[j] = max(dp[j], dp[j-weight[i]] + values[i]);
求组合个数： dp[j] += dp[j-nums[i]];  dp[0] = 1;


完全背包：顺序遍历
 



LCR 126. 斐波那契数
https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/description/
``` cpp 
class Solution {
public:
    int fib(int n) {
        if(n <= 1) return n;
        // 0 1 1 2 
        int pre = 0;
        int cur = 1;
        int res = 0;
        for(int i = 2; i<=n; i++) {
            res = (pre + cur) % 1000000007;
            pre = cur; 
            cur = res;
        }
        return res;
    }
};
```

###############################################################################
01背包
###############################################################################
01 背包： n种物品，每种 1个
完全背包 ： n种物品，每种无限个

* 01 背包 : 1) 纯01背包是装满背包的最大价值；max(dp[j], dp[j-weight[i]]+values[i])  2）装满背包的组合数量；dp[j] += dp[j-weight[i]]
// 取第i个物品的 方法数 +  不取第i个物品的方法数；
** dp[i][j]含义： [0,i]物品任取，放进容量为j背包里面的最大价值；
** dp[i][j] 就是放不放物品i的 状态，最大价值
*** 不放： dp[i-1][j]
*** 放：  dp[i-1][j-weights[i]] + values[i]
一维表示：
dp[j], dp[j-weight[i]] + values[j] // 对于物品i 放和不放；
// 不放物品i，最大价值仍然为历史最大价值dp[j], 放的话就是 dp[j-weight[i]] + values[i]

遍历顺序：二维数组的01背包问题，可以颠倒

一维数组： for 物品， for背包， for背包的时候是需要倒序遍历的，主要是为了不影响之前的值；


* 416. 分割等和子集
https://leetcode.cn/problems/partition-equal-subset-sum/
01 背包
关键理解：
这里重量和价值都是 nums里面的数；
dp[j] 就是背包容量为j的最大价值， 当dp[target] == target 就可以切分
一位数组，先物品，在背包，背包的时候反向遍历，每个物品取一次，避免覆盖； 
``` cpp 
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto num : nums)
            sum+=num;
        if(sum % 2 == 1) return false;
        int target = sum / 2;
        int n = nums.size();
        vector<int> dp(target+1, 0); // dp[j] 背包为j的最大价值；
        for(int i = 0; i < n; i++) {
            for(int j = target; j>=0; j--)
                if(j-nums[i]>=0){
                    dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]);
                }
        }
        return dp[target] == target;
    }
};
```

* 1049. 最后一块石头的重量 II
https://leetcode.cn/problems/last-stone-weight-ii/description/
``` cpp 
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        // 用一个背包为 sum/2 的取尽量装，剩下就是另一对
        int sum = 0;
        for(auto stone : stones)
            sum += stone;
        int target = sum/2;
        vector<int> dp(target+1);
        for(int i = 0; i < stones.size(); i++) {
            for(int j = target; j>= stones[i]; j--)
                dp[j] = max(dp[j], dp[j-stones[i]] + stones[i]);
        }
        return sum - 2*dp[target];
    }
};
```

* 474. 一和零
https://leetcode.cn/problems/ones-and-zeroes/description/
01背包求最大价值类型。 dp[j] = max(dp[j], dp[j-weight[i]] + values[i]);
这里的weight 是一个二维的，每个价值均为1；
``` cpp 
class Solution {
public:
    vector<int> get_cnt(string & str){
        vector<int> res(2,0);
        for(auto c : str){
            res[c-'0']++;
        }
        return res;
    }
    // 0 1 找最大价值，每个价值为1
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        for(int i = 0; i < strs.size(); i++) {
            vector<int> tmp = get_cnt(strs[i]);
            for(int j = m; j >=  tmp[0]; j--)
                for(int k = n; k >= tmp[1]; k--){
                    dp[j][k] = max(dp[j][k], dp[j-tmp[0]][k-tmp[1]] + 1);
                }
        }
        return dp[m][n];
    }
};
```










01背包
https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.337.search-card.all.click&vd_source=ed1ae5cbd4ddff5db18d328c25da5b1e\

dp[i][j]  : [0,i]个物品随便取，放容量为j的背包中，



完全背包， 假设物品为1，2，5；
完全背包  如果 求最大价值，两个for是可以颠倒的； 如果是求组合个数； 物品，容量==》 求组合   容量，物品=》求排列
for(物品)
    for(背包)
这是一种组合： 因为是先把所有的1都装进来了，所以只存在(1,2)这种情况，先for的1，再for的2

for(背包)
    for(物品)
这是一种排列： 因为会存在 （1，2） 和（2，1） 这种情况

dp[i][j] 为组合数量的时候，比如硬币[1,2，5] 组成11
其实是求组合： 所以是for wupin  for 背包； dp[j] += dp[j-weight[i]]  不取i和取i两种情况的组合方式和；


``` cpp 
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> set(wordDict.begin(), wordDict.end());
        int n = s.size();

        vector<bool> dp(n+1,false);
        dp[0] = true; // 第0个字母结尾，为true。 背包为0， 可以拆分
        // dp[i] 表示 以 第i个字母结尾是否可以拆分， 所以word长度为i-j = (i-1) - j + 1;
        // 第i个字母对应的s的idx 为 i-1， j
        for(int i = 1; i <= n; i++) { // 背包
            for(int j = 0; j < i; j++) { // 物品 
                string word = s.substr(j, i-j);
                if(dp[j] && set.find(word) != set.end())
                    dp[i] = true;
            }
        } 
        return dp[n];
    }

    // bool res = false;
    // bool wordBreak(string s, vector<string>& wordDict) {
    //     int n = s.size();
    //     dfs(s, 0, wordDict);
    //     return res;
    // }

    // 回溯会超时
    // void dfs(string s, int begin, vector<string>& wordDict) {
    //     if(res == true) return;
    //     if(begin == s.size()) {
    //         res = true;
    //         return;
    //     }

    //     for(auto word : wordDict) {
    //         int length = word.size();
    //         string ori = s.substr(begin, length);
    //         if(ori != word) continue;
    //         dfs(s, begin + length, wordDict);
    //     }
    // }
};
```

``` cpp 
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1); // 以i结尾的最长递增子序列长度
        int res = 1;
        for(int i = 1; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

``` cpp 
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto num : nums)
            sum+=num;
        if(sum%2 == 1) return false;
        int target = sum/2;
        vector<int> dp(target+1);
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i]);
            }
        }
        return dp[target] == target;
    }
};
```

``` cpp 
class Solution {
public:
    int longestValidParentheses(string s) {
        // int n = s.size();
        // vector<int> dp(n, 0); // 以s[i]结尾的最大长度
        // int cnt = 0;
        // for(int i = 1; i < n; i++) {
        //     if(s[i] == '(') continue;
        //     if(s[i-1] == '(') {
        //         dp[i] = 2 + (i-2>=0 ? dp[i-2] : 0);
        //     } else {
        //         int left = i - dp[i-1];
        //         if(left-1>=0 && s[left-1] == '(') 
        //             dp[i] = 2 + dp[i-1] + (left-2>=0?dp[left-2] : 0);
                    
        //     }
        //     cnt = max(cnt, dp[i]);
        // }
        // return cnt;

        stack<int> stack;
        stack.push(-1);
        int res = 0;
        int length = 0;
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '(') {
                stack.push(i);
            } else {
                // 此时栈顶有可能是( 或者)
                stack.pop();
                if(stack.empty()) {
                    length = 0;
                    stack.push(i);
                } else {
                    length = i - stack.top();
                }
                res = max(res, length);
            }
        }
        return res;

        // int left = 0, right = 0;
        // int res = 0;
        // for(int i = 0; i < s.size(); i++) {
        //     if(s[i] == '(') {
        //         left++;
        //     } else {
        //         right++;
        //     }
        //     if(left == right) {
        //         res = max(res, left*2);
        //     } else if(right > left){
        //         left = 0;
        //         right = 0;
        //     }
        // }
        // left = 0, right = 0;
        // for(int i = s.size()-1; i >=0; i--) {
        //     if(s[i] == '(') {
        //         left++;
        //     } else {
        //         right++;
        //     }
        //     if(left == right) {
        //         res = max(res, left*2);
        //     } else if(right < left){
        //         left = 0;
        //         right = 0;
        //     }
        // }
        // return res;
    }
};
``` 


###############################################################################
完全背包
###############################################################################
518. 零钱兑换 II
# https://leetcode.cn/problems/coin-change-ii/description/

``` cpp 
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        // dp[j]  考虑【0，j】硬币的 最大组合数量
        // dp[i-1][j] bukaolv   dp[]
        vector<int> dp(amount+1);
        dp[0] = 1;
        for(int i = 0; i < n; i++) {
            for(int j = coins[i]; j <= amount; j++) 
                dp[j] += dp[j-coins[i]];
        }
        return dp[amount];
    }
};
```


* 377. 组合总和 Ⅳ
# https://leetcode.cn/problems/combination-sum-iv/description/
```

class Solution {
public:
    // 01 背包； 组合个数，而不是最大价值
    int combinationSum4(vector<int>& nums, int target) {
        vector<unsigned long long> dp(target+1, 0);
        dp[0] = 1;    
        // for(int i = 0; i < nums.size(); i++) {
        //     for(int j = nums[i]; j <= target; j++) {
        //         dp[j] += dp[j-nums[i]];
        //     }
        // }
        for(int j = 0; j <= target; j++) {
            for(int i = 0; i < nums.size(); i++) {
                //完全背包顺序，序列问题 改变遍历顺序
                if(j - nums[i] < 0) continue; 
                dp[j] += dp[j-nums[i]];
            }
        }
        return dp[target];    
    }
};
```

* 322. 零钱兑换
https://leetcode.cn/problems/coin-change/
``` cpp 
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 完全背包 for 正序for 
        // 组合问题；for物品 for 背包
        // 最小的组合个数问题；
        vector<int> dp(amount+1, amount+1);
        dp[0] = 0;
        for(int i = 0; i < coins.size(); i++) {
            //  完全背包，都正序
            for(int j = coins[i]; j <= amount; j++) {
                dp[j] = min(dp[j], dp[j-coins[i]] + 1);
            }
        }
        return dp[amount] == amount+1 ? -1 : dp[amount];
    }
};
```

* 279. 完全平方数
https://leetcode.cn/problems/perfect-squares/description/
``` cpp 
class Solution {
public:
    int numSquares(int n) {
        int cnt = sqrt(n);
        //完全背包 for正
        //组合问题，for 物品for背包
        vector<int> dp(n+1, n+1);
        dp[0] = 0;
        for(int i = 1; i <= cnt; i++) { // for 物品
            for(int j = i*i; j <= n; j++) { // for 背包
                dp[j] = min(dp[j], dp[j-i*i]+1);
            }
        }
        return dp[n];
    }
};
```



###############################################################################
打家劫舍问题
###############################################################################

dp[i] 考虑下标i，能偷到的最大金额
dp[i] = max(dp[i-2] + nums[i], dp[i-1]) ， 注意这里的i-1可能也没偷，仅仅是考虑以i-1结尾的最大金额；
dp[0] = nums[0], dp[1] = max(nums[0], nums[1])

* 198. 打家劫舍
https://leetcode.cn/problems/house-robber/description/
``` cpp 
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i-1], dp[i-2]+nums[i]);
        }
        return dp[nums.size()-1];
    }
};

// 另一种思路； 对每一个i 都保留两种状态，偷或不偷，类似买股票;
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        int tou = nums[0];
        int bu_tou = 0;
        int res = INT_MIN;
        for(int i = 1; i < nums.size(); i++) {
            int tmp = tou;
            tou = max(tou, bu_tou + nums[i]);
            bu_tou = max(tmp, bu_tou);
            res = max(res, bu_tou);
            res = max(res, tou);
        }
        return res;
    }
};
```

* 213. 打家劫舍 II
https://leetcode.cn/problems/house-robber-ii/description/
// 连成环了，掐头去尾来计算；
[0, n-2]
[1, n-1] 各算一次 取 max
``` cpp 
class Solution {
public:
    int get_max(vector<int>& nums, int left, int right) {
        int n = right - left + 1;
        vector<int> dp(n, 0);
        dp[0] = nums[left];
        dp[1] = max(nums[left], nums[left+1]);
        for(int i = left+2; i <= right; i++) {
            dp[i-left] = max(dp[i-1-left], dp[i-2-left] + nums[i]);
        }
        return dp[n-1];
        
    }
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        return max(get_max(nums, 0, nums.size()-2), get_max(nums, 1, nums.size()-1));
    }
};
```

* 337. 打家劫舍 III
https://leetcode.cn/problems/house-robber-iii/description/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 后续遍历
    // 保留 偷或者不偷的最大值
    // 0 = tou. 1 = butou
    vector<int> robb(TreeNode* root) {
        if(root == NULL) return {0, 0};
        vector<int> left = robb(root->left);
        vector<int> right = robb(root->right);
        int res1 = left[1] + right[1] + root->val;
        int res2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {res1, res2};
    }
    int rob(TreeNode* root) {
        if(root == NULL) return 0;
        vector<int> res = robb(root);
        return max(res[0], res[1]);
    }
};



###############################################################################
买卖股票
###############################################################################
两个状态： dp[i][0]  dp[i][1]  第i天持有股票 & 第i天不持有股票 ，解决一系列买卖股票问题
这里也可以设计成3种状态： 不操作； 持有、不持有； 


121. 买卖股票的最佳时机
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/


class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2,0));
        // 0:have   , 1:not have
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < n; i++) {
            dp[i][0] = max(-prices[i], dp[i-1][0]);
            dp[i][1] = max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return max(dp[n-1][0], dp[n-1][1]);
    }
};


122. 买卖股票的最佳时机 II: 多次买卖
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
多次买卖；在 持有状态下的不一样； 看是不是继承之前的状态，继承之前的状态则是多次买卖的情况；

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2,0));
        // 0 : have. 1:not have
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i-1][1]-prices[i], dp[i-1][0]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0], dp[n-1][1]);
    }
};

123. 买卖股票的最佳时机 III
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<int> dp(4, INT_MIN);
        dp[0] = -prices[0];
        dp[1] = 0;
        dp[2] = -prices[0];
        dp[3] = 0;
        for(int i = 1; i < n; i++) {
            dp[0] = max(dp[0], -prices[i]);
            dp[1] = max(dp[1], dp[0] + prices[i]);
            dp[2] = max(dp[2], dp[1] - prices[i]);
            dp[3] = max(dp[3], dp[2] + prices[i]);
        }
        return dp[3];

        // int n = prices.size();
        // vector<vector<int>> dp(n, vector<int>(4, INT_MIN));
        // dp[0][0] = -prices[0];
        // dp[0][1] = 0;
        // dp[0][2] = -prices[0];
        // dp[0][3] = 0;
        // for(int i = 1; i < n; i++) {
        //     dp[i][0] = max(dp[i-1][0], -prices[i]);
        //     dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        //     dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]);
        //     dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]);
        // }
        // return dp[n-1][3];
    }
};

309. 买卖股票的最佳时机含冷冻期
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n][3];  //以第i天结束后的收益，共3种状态
        //[i][0] 有一只支票
        //[i][1] 无支票冷冻期
        //[i][2] 无支票 非冷冻期 
        memset(dp, 0, sizeof(dp));
        int res = 0;
        dp[0][0] = -prices[0]; //第一天买入 收益为负
        for(int i = 1; i < n; i++) {
            // 有支票；前一天也有支票,当天未做任何东西 || 前一天无股票 非冷冻期，第i天买了股票
            dp[i][0] = max(dp[i-1][0],dp[i-1][2] - prices[i]);
            // 无股票，冷冻期: 今天卖了股票，昨天有支票 
            dp[i][1] = dp[i-1][0]+prices[i];
            // 无股票，非冷冻;昨天无支票冷冻期啥也没干 ｜｜ 昨天无支票 非冷冻期啥也没干
            dp[i][2] = max(dp[i-1][1],dp[i-1][2]);
            res = max(max(res, dp[i][1]),dp[i][2]);
        }
        return res;
    }
};



###############################################################################
子序列
###############################################################################


300. 最长递增子序列
https://leetcode.cn/problems/longest-increasing-subsequence/description/
和 nums种判断 i和j的回文子串差不多；


对于i而言，从[0, i]中 找一个开始  dp[i] = dp[j] + 1, dp[i]
dp[i] 以i结尾的最长递增子序列长度


class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1); // dp[i] 表示i结尾的数字的最长自增子序列
        vector<int> vec(n, -1);
        int res = 1;
        for(int i = 0; i < n; i++) {
            for(int j = max(0, vec[i]); j < i; j++) {
                if(nums[i] > nums[j]) {
                    
                    // 这里是一个优化，保留i的上一个点的最小值的索引，下次从这个索引开始遍历
                    if(dp[j]+1 > dp[i]) {
                        vec[i] = nums[j];
                    } else if (dp[j]+1 == dp[i]) {
                        vec[i] = min(vec[i], nums[j]);
                    }

                    dp[i] = max(dp[i], dp[j] + 1);
                }
                res = max(res, dp[i]);
            }
        } 
        return res;
    }
};



674. 最长连续递增序列
https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/
这里的左侧起始点就是  nums[i-1];
而上面那个题需要取找一个 num[j] < nums[i] 来确定起点；

class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
       int length = 1;  // 以i结尾的最大长度
       int res = 1;
       for(int i = 1; i < nums.size(); i++) {
        if(nums[i] > nums[i-1]) {
            length += 1;
        } else {
            length = 1;
        }
        res = max(res, length);
       }
       return res;
    }
};


718. 最长重复子数组

https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/
dp[i][j] 表示以i-1 , j-1结尾的最长重复子数组； 
所以遍历的时候是 i<=m  j<=n  判断的时候是 [i-1] == [j-1]
//方便初始化
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size();
        int n = nums2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        //dp[i][j] 以i-1 .j-1结尾的最长重复子数组；
        // 方便初始化
        int res = 0;
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(nums1[i-1] == nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};


1143. 最长公共子序列
https://leetcode.cn/problems/longest-common-subsequence/description/
dp[i][j] 以[i-1][j-1]结尾的最长公共子序列；
i <=m j <=n 遍历，比较的时候用 i-1  j-1的结果
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        // dp[i][j] 以[i-1] [j-1]结尾的最长公共子序列
        int res = 0;
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(text1[i-1] == text2[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};



53. 最大子数组和
https://leetcode.cn/problems/maximum-subarray/

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            pre = max(pre + nums[i], nums[i]);
            res = max(res, pre);
        }
        return res;
    }
};


392. 判断子序列
https://leetcode.cn/problems/is-subsequence/description/

class Solution {
public:
    bool isSubsequence(string s, string t) {
        int idx1 = 0;
        int idx2 = 0;
        int valid = 0;
        while(idx1 < s.size() && idx2 < t.size()) {
            if(s[idx1] != t[idx2]){
                idx2++;
            } else {
                idx1++;
                idx2++;
                valid++;
            }
        }
        return valid == s.size();
    }
};



115. 不同的子序列
https://leetcode.cn/problems/distinct-subsequences/description/

这里的状态转移比较奇怪； 用最后一个字母，不用最后一个字母；

有多少种s中删除元素的方法得到字符串t；
dp[i][j]定义：  以i-1 j-1结尾的s种 包含t序列的个数；
i-1 == j-1的时候， 考虑用最后一个i-1 就是 dp[i-1][j-1] ,不考虑用最后一个i-1 就是 dp[i-2][j-1]
i-1 != j-1, dp[i-2][j-1]



class Solution {
public:
    int numDistinct(string s, string t) {
        // 有多少种s中删除元素的方法得到字符串t；
        // dp[i][j]定义：  以i-1 j-1结尾的s种 包含t序列的个数；
        // i-1 == j-1的时候， 考虑用最后一个i-1 就是 dp[i-1][j-1] ,不考虑用最后一个i-1 就是 dp[i-2][j-1]
        // i-1 != j-1, dp[i-2][j-1]
        int m = s.size();
        int n = t.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        // dp[i][0] 第1列；t=“”；所以 均为1；全部删除
        // dp[0][i] s为空；
        for(int i = 0; i < m; i++)
            dp[i][0] = 1;
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(s[i-1] == t[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; //用最后一个字母 + 不用最后一个字母
                    dp[i][j] %= 1000000007;
                } else {
                    dp[i][j] = dp[i-1][j];
                    dp[i][j] %= 1000000007;
                }
            }
        }
        return dp[m][n];
    }
};


583. 两个字符串的删除操作
https://leetcode.cn/problems/delete-operation-for-two-strings/description/


class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1,0));
        for(int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for(int i = 0; i <= n; i++) 
            dp[0][i] = i;
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(word1[i-1] == word2[j-1]) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1])+1;
                    dp[i][j] = min(dp[i-1][j-1]+2, dp[i][j]);
                }
            }
        }
        return dp[m][n];
    }
};


72. 编辑距离
https://leetcode.cn/problems/edit-distance/description/
1、初始化， 不是全0或者全1；
2、 两个字母不相等的情况下，考虑3个位置的min； 增删改 对应[i][j-1]  [i-1][j]   [i-1][j-1];
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        for(int i = 1; i <= m; i++) 
            dp[i][0] = i;
        for(int i = 1; i <= n; i++)
            dp[0][i] = i;
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(word1[i-1] == word2[j-1]) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]);
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                    dp[i][j] += 1;
                }

            }
        }
        return dp[m][n];
    }
};


647. 回文子串
https://leetcode.cn/problems/palindromic-substrings/description/

class Solution {
public:
    int countSubstrings(string s) {
        // dp[i][j] [i,j]是否为回文子串
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for(int i = s.size()-1; i >= 0; i--) {
            for(int j = i; j < n; j++) {
                if(s[i] == s[j]) {
                    if(j - i <= 1) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
            }
        }
        int sum = 0;
        for(int i = 0; i <n; i++) {
            sum += reduce(dp[i].begin(), dp[i].end());
        }
        return sum;
    }
};

516. 最长回文子序列
https://leetcode.cn/problems/longest-palindromic-subsequence/

从递推找遍历顺序； 从左下开始遍历；
注意这里j是从i开始遍历的, 不是从0开始遍历的,dp[i][j]假定j>=i
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        int res = 1;
        for(int i = 0; i < n; i++)
            dp[i][i] = 1;
        for(int i = n-1; i>=0; i--) {
            for(int j = i; j < n; j++) {
                if(s[i] == s[j]) {
                    if(j-i <= 1) {
                        dp[i][j] = j-i+1;
                    } else {
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                } else {
                    dp[i][j] = max(dp[i][j-1], dp[i+1][j]);
                }
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};

5. 最长回文子串
https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        // dp[i][j] [i,j]
        string res;
        for(int i = n - 1; i >= 0; i--) {
            for(int j = i; j < n; j++) {
                // 注意这里j是从i开始遍历的, 不是从0开始遍历的,dp[i][j]假定j>=i
                if(s[i] == s[j]) {
                    if(j-i<=2) {
                        dp[i][j] = true;
                    }else {
                        dp[i][j] = dp[i+1][j-1];
                    }
                    if(dp[i][j] == true && j-i+1 > res.size()) {
                        res = s.substr(i, j-i+1);
                    }
                } 
            }
        }
        return res;
    }
};
